# ğŸ“Š æ•°æ®å¯¼å…¥å¯¼å‡ºåŠŸèƒ½è®¾è®¡æ–‡æ¡£

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è®¾è®¡äº†æ•°å­—é’±åŒ…ç®¡ç†åå°çš„æ•°æ®å¯¼å…¥å¯¼å‡ºåŠŸèƒ½ï¼Œæ”¯æŒç”¨æˆ·æ•°æ®ã€äº¤æ˜“è®°å½•ã€é’±åŒ…ä¿¡æ¯ã€ä»»åŠ¡æ•°æ®ã€çº¢åŒ…è®°å½•ã€å›¢é˜Ÿæ•°æ®ã€æ’è¡Œæ¦œæ•°æ®ç­‰çš„æ‰¹é‡å¯¼å…¥å¯¼å‡ºï¼Œæä¾›å¤šç§æ ¼å¼æ”¯æŒå’Œå®‰å…¨ä¿éšœæœºåˆ¶ã€‚

## åŠŸèƒ½æ¶æ„

### 1. æ•´ä½“æ¶æ„è®¾è®¡

```mermaid
graph TB
    A[æ•°æ®å¯¼å…¥å¯¼å‡ºæœåŠ¡] --> B[æ ¼å¼å¤„ç†å™¨]
    A --> C[æ•°æ®éªŒè¯å™¨]
    A --> D[æƒé™æ§åˆ¶å™¨]
    A --> E[ä»»åŠ¡ç®¡ç†å™¨]
    
    B --> B1[Excelå¤„ç†å™¨]
    B --> B2[CSVå¤„ç†å™¨]
    B --> B3[JSONå¤„ç†å™¨]
    B --> B4[PDFç”Ÿæˆå™¨]
    
    C --> C1[æ•°æ®æ ¼å¼éªŒè¯]
    C --> C2[ä¸šåŠ¡è§„åˆ™éªŒè¯]
    C --> C3[æ•°æ®å®Œæ•´æ€§æ£€æŸ¥]
    
    D --> D1[æ“ä½œæƒé™éªŒè¯]
    D --> D2[æ•°æ®è®¿é—®æ§åˆ¶]
    D --> D3[æ•æ„Ÿæ•°æ®è„±æ•]
    
    E --> E1[å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—]
    E --> E2[è¿›åº¦è·Ÿè¸ª]
    E --> E3[é”™è¯¯å¤„ç†]
    E --> E4[ç»“æœé€šçŸ¥]
```

### 2. æ”¯æŒçš„æ•°æ®ç±»å‹

#### æ ¸å¿ƒæ•°æ®æ¨¡å—
```javascript
/**
 * æ•°æ®å¯¼å…¥å¯¼å‡ºæ¨¡å—é…ç½®
 */
const DATA_MODULES = {
  // ç”¨æˆ·æ•°æ®
  users: {
    name: 'ç”¨æˆ·æ•°æ®',
    description: 'ç”¨æˆ·åŸºæœ¬ä¿¡æ¯ã€çŠ¶æ€ã€ç»Ÿè®¡æ•°æ®',
    supportedFormats: ['excel', 'csv', 'json'],
    permissions: ['admin', 'user_manager'],
    sensitiveFields: ['phone', 'email', 'id_card'],
    maxRecords: 10000
  },
  
  // é’±åŒ…æ•°æ®
  wallets: {
    name: 'é’±åŒ…æ•°æ®',
    description: 'é’±åŒ…åœ°å€ã€ä½™é¢ã€çŠ¶æ€ä¿¡æ¯',
    supportedFormats: ['excel', 'csv', 'json'],
    permissions: ['admin', 'finance_manager'],
    sensitiveFields: ['private_key', 'mnemonic'],
    maxRecords: 50000
  },
  
  // äº¤æ˜“è®°å½•
  transactions: {
    name: 'äº¤æ˜“è®°å½•',
    description: 'å……å€¼ã€æç°ã€è½¬è´¦ç­‰äº¤æ˜“æ•°æ®',
    supportedFormats: ['excel', 'csv', 'json', 'pdf'],
    permissions: ['admin', 'finance_manager', 'auditor'],
    sensitiveFields: ['from_address', 'to_address'],
    maxRecords: 100000
  },
  
  // ä»»åŠ¡æ•°æ®
  tasks: {
    name: 'ä»»åŠ¡æ•°æ®',
    description: 'ç”¨æˆ·ä»»åŠ¡å®Œæˆæƒ…å†µå’Œå¥–åŠ±è®°å½•',
    supportedFormats: ['excel', 'csv', 'json'],
    permissions: ['admin', 'operation_manager'],
    sensitiveFields: [],
    maxRecords: 200000
  },
  
  // çº¢åŒ…è®°å½•
  redPackets: {
    name: 'çº¢åŒ…è®°å½•',
    description: 'çº¢åŒ…å‘æ”¾ã€é¢†å–ã€ä½¿ç”¨è®°å½•',
    supportedFormats: ['excel', 'csv', 'json'],
    permissions: ['admin', 'operation_manager'],
    sensitiveFields: ['recipient_phone'],
    maxRecords: 500000
  },
  
  // å›¢é˜Ÿæ•°æ®
  teams: {
    name: 'å›¢é˜Ÿæ•°æ®',
    description: 'å›¢é˜Ÿç»“æ„ã€æˆå‘˜å…³ç³»ã€ä¸šç»©ç»Ÿè®¡',
    supportedFormats: ['excel', 'csv', 'json'],
    permissions: ['admin', 'team_manager'],
    sensitiveFields: ['member_phone', 'member_email'],
    maxRecords: 20000
  },
  
  // æ’è¡Œæ¦œæ•°æ®
  rankings: {
    name: 'æ’è¡Œæ¦œæ•°æ®',
    description: 'å„ç±»æ’è¡Œæ¦œæ•°æ®å’Œå†å²è®°å½•',
    supportedFormats: ['excel', 'csv', 'json', 'pdf'],
    permissions: ['admin', 'operation_manager'],
    sensitiveFields: [],
    maxRecords: 10000
  },
  
  // ç³»ç»Ÿæ—¥å¿—
  systemLogs: {
    name: 'ç³»ç»Ÿæ—¥å¿—',
    description: 'æ“ä½œæ—¥å¿—ã€é”™è¯¯æ—¥å¿—ã€å®¡è®¡è®°å½•',
    supportedFormats: ['csv', 'json'],
    permissions: ['admin', 'system_manager'],
    sensitiveFields: ['ip_address', 'user_agent'],
    maxRecords: 1000000
  }
};
```

## æ•°æ®å¯¼å‡ºåŠŸèƒ½

### 1. å¯¼å‡ºæœåŠ¡æ ¸å¿ƒç±»

#### æ•°æ®å¯¼å‡ºç®¡ç†å™¨
```javascript
/**
 * æ•°æ®å¯¼å‡ºç®¡ç†å™¨
 */
const ExcelJS = require('exceljs');
const PDFDocument = require('pdfkit');
const fs = require('fs').promises;
const path = require('path');

class DataExportManager {
  constructor(db, taskQueue, permissionService) {
    this.db = db;
    this.taskQueue = taskQueue;
    this.permissionService = permissionService;
    this.exportPath = process.env.EXPORT_PATH || './exports';
    this.maxFileSize = 100 * 1024 * 1024; // 100MB
  }
  
  /**
   * åˆ›å»ºå¯¼å‡ºä»»åŠ¡
   */
  async createExportTask(userId, moduleType, options = {}) {
    // æƒé™éªŒè¯
    await this.permissionService.checkPermission(
      userId, 
      `export_${moduleType}`
    );
    
    const module = DATA_MODULES[moduleType];
    if (!module) {
      throw new Error(`ä¸æ”¯æŒçš„æ•°æ®æ¨¡å—: ${moduleType}`);
    }
    
    // åˆ›å»ºå¯¼å‡ºä»»åŠ¡
    const taskId = `export_${moduleType}_${Date.now()}_${userId}`;
    const task = {
      id: taskId,
      userId,
      moduleType,
      moduleName: module.name,
      format: options.format || 'excel',
      filters: options.filters || {},
      columns: options.columns || [],
      status: 'pending',
      progress: 0,
      totalRecords: 0,
      processedRecords: 0,
      filePath: null,
      fileSize: 0,
      createdAt: new Date(),
      startedAt: null,
      completedAt: null,
      error: null
    };
    
    // ä¿å­˜ä»»åŠ¡è®°å½•
    await this.saveExportTask(task);
    
    // æ·»åŠ åˆ°å¼‚æ­¥é˜Ÿåˆ—
    await this.taskQueue.add('data-export', task, {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 2000
      }
    });
    
    return {
      taskId,
      message: 'å¯¼å‡ºä»»åŠ¡å·²åˆ›å»ºï¼Œæ­£åœ¨å¤„ç†ä¸­...',
      estimatedTime: this.estimateExportTime(moduleType, options)
    };
  }
  
  /**
   * æ‰§è¡Œæ•°æ®å¯¼å‡º
   */
  async executeExport(task) {
    try {
      await this.updateTaskStatus(task.id, 'processing', { startedAt: new Date() });
      
      // è·å–æ•°æ®
      const data = await this.fetchExportData(task);
      
      // æ•°æ®è„±æ•å¤„ç†
      const sanitizedData = await this.sanitizeData(data, task.moduleType);
      
      // ç”Ÿæˆæ–‡ä»¶
      const filePath = await this.generateExportFile(sanitizedData, task);
      
      // æ›´æ–°ä»»åŠ¡çŠ¶æ€
      await this.updateTaskStatus(task.id, 'completed', {
        filePath,
        fileSize: (await fs.stat(filePath)).size,
        completedAt: new Date(),
        totalRecords: data.length
      });
      
      // å‘é€å®Œæˆé€šçŸ¥
      await this.notifyExportComplete(task);
      
      return filePath;
    } catch (error) {
      await this.updateTaskStatus(task.id, 'failed', {
        error: error.message,
        completedAt: new Date()
      });
      
      throw error;
    }
  }
  
  /**
   * è·å–å¯¼å‡ºæ•°æ®
   */
  async fetchExportData(task) {
    const { moduleType, filters } = task;
    
    switch (moduleType) {
      case 'users':
        return await this.fetchUserData(filters);
      case 'wallets':
        return await this.fetchWalletData(filters);
      case 'transactions':
        return await this.fetchTransactionData(filters);
      case 'tasks':
        return await this.fetchTaskData(filters);
      case 'redPackets':
        return await this.fetchRedPacketData(filters);
      case 'teams':
        return await this.fetchTeamData(filters);
      case 'rankings':
        return await this.fetchRankingData(filters);
      case 'systemLogs':
        return await this.fetchSystemLogData(filters);
      default:
        throw new Error(`ä¸æ”¯æŒçš„æ•°æ®æ¨¡å—: ${moduleType}`);
    }
  }
  
  /**
   * è·å–ç”¨æˆ·æ•°æ®
   */
  async fetchUserData(filters) {
    let query = `
      SELECT 
        u.id,
        u.username,
        u.phone,
        u.email,
        u.status,
        u.level,
        u.created_at,
        u.last_login_at,
        w.balance,
        w.frozen_balance,
        (SELECT COUNT(*) FROM transactions t WHERE t.user_id = u.id) as transaction_count,
        (SELECT COUNT(*) FROM user_tasks ut WHERE ut.user_id = u.id AND ut.status = 'completed') as completed_tasks
      FROM users u
      LEFT JOIN wallets w ON u.id = w.user_id
      WHERE u.deleted_at IS NULL
    `;
    
    const conditions = [];
    const params = [];
    
    // åº”ç”¨è¿‡æ»¤æ¡ä»¶
    if (filters.status) {
      conditions.push('u.status = ?');
      params.push(filters.status);
    }
    
    if (filters.level) {
      conditions.push('u.level = ?');
      params.push(filters.level);
    }
    
    if (filters.dateRange) {
      conditions.push('u.created_at BETWEEN ? AND ?');
      params.push(filters.dateRange.start, filters.dateRange.end);
    }
    
    if (filters.minBalance) {
      conditions.push('w.balance >= ?');
      params.push(filters.minBalance);
    }
    
    if (conditions.length > 0) {
      query += ' AND ' + conditions.join(' AND ');
    }
    
    query += ' ORDER BY u.created_at DESC';
    
    if (filters.limit) {
      query += ` LIMIT ${parseInt(filters.limit)}`;
    }
    
    return await this.db.query(query, params);
  }
  
  /**
   * è·å–äº¤æ˜“æ•°æ®
   */
  async fetchTransactionData(filters) {
    let query = `
      SELECT 
        t.id,
        t.user_id,
        u.username,
        t.type,
        t.amount,
        t.fee,
        t.status,
        t.from_address,
        t.to_address,
        t.tx_hash,
        t.block_number,
        t.created_at,
        t.confirmed_at
      FROM transactions t
      LEFT JOIN users u ON t.user_id = u.id
      WHERE 1=1
    `;
    
    const conditions = [];
    const params = [];
    
    if (filters.type) {
      conditions.push('t.type = ?');
      params.push(filters.type);
    }
    
    if (filters.status) {
      conditions.push('t.status = ?');
      params.push(filters.status);
    }
    
    if (filters.dateRange) {
      conditions.push('t.created_at BETWEEN ? AND ?');
      params.push(filters.dateRange.start, filters.dateRange.end);
    }
    
    if (filters.minAmount) {
      conditions.push('t.amount >= ?');
      params.push(filters.minAmount);
    }
    
    if (filters.userId) {
      conditions.push('t.user_id = ?');
      params.push(filters.userId);
    }
    
    if (conditions.length > 0) {
      query += ' AND ' + conditions.join(' AND ');
    }
    
    query += ' ORDER BY t.created_at DESC';
    
    if (filters.limit) {
      query += ` LIMIT ${parseInt(filters.limit)}`;
    }
    
    return await this.db.query(query, params);
  }
  
  /**
   * æ•°æ®è„±æ•å¤„ç†
   */
  async sanitizeData(data, moduleType) {
    const module = DATA_MODULES[moduleType];
    if (!module.sensitiveFields || module.sensitiveFields.length === 0) {
      return data;
    }
    
    return data.map(record => {
      const sanitized = { ...record };
      
      module.sensitiveFields.forEach(field => {
        if (sanitized[field]) {
          sanitized[field] = this.maskSensitiveData(sanitized[field], field);
        }
      });
      
      return sanitized;
    });
  }
  
  /**
   * æ•æ„Ÿæ•°æ®æ©ç 
   */
  maskSensitiveData(value, fieldType) {
    if (!value) return value;
    
    switch (fieldType) {
      case 'phone':
        return value.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
      case 'email':
        return value.replace(/(.{2}).*(@.*)/, '$1****$2');
      case 'id_card':
        return value.replace(/(\d{6})\d{8}(\d{4})/, '$1********$2');
      case 'from_address':
      case 'to_address':
        return value.replace(/(.{6}).*(.{6})/, '$1****$2');
      case 'private_key':
      case 'mnemonic':
        return '***å·²éšè—***';
      default:
        return value.replace(/(.{2}).*(.{2})/, '$1****$2');
    }
  }
  
  /**
   * ç”Ÿæˆå¯¼å‡ºæ–‡ä»¶
   */
  async generateExportFile(data, task) {
    const { format, moduleType } = task;
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `${moduleType}_export_${timestamp}.${format}`;
    const filePath = path.join(this.exportPath, filename);
    
    // ç¡®ä¿å¯¼å‡ºç›®å½•å­˜åœ¨
    await fs.mkdir(this.exportPath, { recursive: true });
    
    switch (format) {
      case 'excel':
        return await this.generateExcelFile(data, filePath, task);
      case 'csv':
        return await this.generateCSVFile(data, filePath, task);
      case 'json':
        return await this.generateJSONFile(data, filePath, task);
      case 'pdf':
        return await this.generatePDFFile(data, filePath, task);
      default:
        throw new Error(`ä¸æ”¯æŒçš„å¯¼å‡ºæ ¼å¼: ${format}`);
    }
  }
  
  /**
   * ç”ŸæˆExcelæ–‡ä»¶
   */
  async generateExcelFile(data, filePath, task) {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet(task.moduleName);
    
    if (data.length === 0) {
      worksheet.addRow(['æ— æ•°æ®']);
      await workbook.xlsx.writeFile(filePath);
      return filePath;
    }
    
    // è®¾ç½®åˆ—æ ‡é¢˜
    const columns = Object.keys(data[0]).map(key => ({
      header: this.getColumnDisplayName(key, task.moduleType),
      key: key,
      width: this.getColumnWidth(key)
    }));
    
    worksheet.columns = columns;
    
    // è®¾ç½®æ ‡é¢˜æ ·å¼
    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' }
    };
    
    // æ·»åŠ æ•°æ®è¡Œ
    data.forEach((record, index) => {
      const row = worksheet.addRow(record);
      
      // è®¾ç½®æ•°æ®æ ¼å¼
      Object.keys(record).forEach((key, colIndex) => {
        const cell = row.getCell(colIndex + 1);
        
        if (key.includes('amount') || key.includes('balance')) {
          cell.numFmt = '#,##0.00';
        } else if (key.includes('_at') && record[key]) {
          cell.value = new Date(record[key]);
          cell.numFmt = 'yyyy-mm-dd hh:mm:ss';
        }
      });
      
      // æ›´æ–°è¿›åº¦
      if (index % 1000 === 0) {
        const progress = Math.floor((index / data.length) * 100);
        this.updateTaskProgress(task.id, progress);
      }
    });
    
    // è‡ªåŠ¨è°ƒæ•´åˆ—å®½
    worksheet.columns.forEach(column => {
      if (!column.width) {
        column.width = 15;
      }
    });
    
    await workbook.xlsx.writeFile(filePath);
    return filePath;
  }
  
  /**
   * ç”ŸæˆCSVæ–‡ä»¶
   */
  async generateCSVFile(data, filePath, task) {
    const createCsvWriter = require('csv-writer').createObjectCsvWriter;
    
    if (data.length === 0) {
      await fs.writeFile(filePath, 'æ— æ•°æ®\n', 'utf8');
      return filePath;
    }
    
    const headers = Object.keys(data[0]).map(key => ({
      id: key,
      title: this.getColumnDisplayName(key, task.moduleType)
    }));
    
    const csvWriter = createCsvWriter({
      path: filePath,
      header: headers,
      encoding: 'utf8'
    });
    
    // åˆ†æ‰¹å†™å…¥æ•°æ®ï¼Œé¿å…å†…å­˜æº¢å‡º
    const batchSize = 5000;
    for (let i = 0; i < data.length; i += batchSize) {
      const batch = data.slice(i, i + batchSize);
      
      if (i === 0) {
        await csvWriter.writeRecords(batch);
      } else {
        // è¿½åŠ æ¨¡å¼å†™å…¥
        const csvWriterAppend = createCsvWriter({
          path: filePath,
          header: headers,
          append: true
        });
        await csvWriterAppend.writeRecords(batch);
      }
      
      // æ›´æ–°è¿›åº¦
      const progress = Math.floor(((i + batch.length) / data.length) * 100);
      await this.updateTaskProgress(task.id, progress);
    }
    
    return filePath;
  }
  
  /**
   * ç”ŸæˆJSONæ–‡ä»¶
   */
  async generateJSONFile(data, filePath, task) {
    const exportData = {
      module: task.moduleName,
      exportTime: new Date().toISOString(),
      totalRecords: data.length,
      data: data
    };
    
    await fs.writeFile(filePath, JSON.stringify(exportData, null, 2), 'utf8');
    return filePath;
  }
  
  /**
   * ç”ŸæˆPDFæŠ¥è¡¨
   */
  async generatePDFFile(data, filePath, task) {
    const doc = new PDFDocument({ margin: 50 });
    const stream = fs.createWriteStream(filePath);
    doc.pipe(stream);
    
    // æ·»åŠ æ ‡é¢˜
    doc.fontSize(20).text(task.moduleName + ' å¯¼å‡ºæŠ¥è¡¨', { align: 'center' });
    doc.moveDown();
    
    // æ·»åŠ å¯¼å‡ºä¿¡æ¯
    doc.fontSize(12)
       .text(`å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}`)
       .text(`è®°å½•æ€»æ•°: ${data.length}`)
       .moveDown();
    
    if (data.length === 0) {
      doc.text('æ— æ•°æ®');
    } else {
      // æ ¹æ®æ•°æ®ç±»å‹ç”Ÿæˆä¸åŒçš„æŠ¥è¡¨æ ¼å¼
      switch (task.moduleType) {
        case 'transactions':
          await this.generateTransactionPDFReport(doc, data);
          break;
        case 'rankings':
          await this.generateRankingPDFReport(doc, data);
          break;
        default:
          await this.generateGenericPDFReport(doc, data);
      }
    }
    
    doc.end();
    
    return new Promise((resolve, reject) => {
      stream.on('finish', () => resolve(filePath));
      stream.on('error', reject);
    });
  }
  
  /**
   * è·å–åˆ—æ˜¾ç¤ºåç§°
   */
  getColumnDisplayName(key, moduleType) {
    const columnNames = {
      // é€šç”¨å­—æ®µ
      id: 'ID',
      created_at: 'åˆ›å»ºæ—¶é—´',
      updated_at: 'æ›´æ–°æ—¶é—´',
      status: 'çŠ¶æ€',
      
      // ç”¨æˆ·ç›¸å…³
      user_id: 'ç”¨æˆ·ID',
      username: 'ç”¨æˆ·å',
      phone: 'æ‰‹æœºå·',
      email: 'é‚®ç®±',
      level: 'ç­‰çº§',
      last_login_at: 'æœ€åç™»å½•',
      
      // é’±åŒ…ç›¸å…³
      address: 'é’±åŒ…åœ°å€',
      balance: 'ä½™é¢',
      frozen_balance: 'å†»ç»“ä½™é¢',
      
      // äº¤æ˜“ç›¸å…³
      type: 'äº¤æ˜“ç±»å‹',
      amount: 'é‡‘é¢',
      fee: 'æ‰‹ç»­è´¹',
      from_address: 'å‘é€åœ°å€',
      to_address: 'æ¥æ”¶åœ°å€',
      tx_hash: 'äº¤æ˜“å“ˆå¸Œ',
      block_number: 'åŒºå—å·',
      confirmed_at: 'ç¡®è®¤æ—¶é—´',
      
      // ä»»åŠ¡ç›¸å…³
      task_name: 'ä»»åŠ¡åç§°',
      reward_amount: 'å¥–åŠ±é‡‘é¢',
      completed_at: 'å®Œæˆæ—¶é—´',
      
      // çº¢åŒ…ç›¸å…³
      packet_amount: 'çº¢åŒ…é‡‘é¢',
      packet_count: 'çº¢åŒ…æ•°é‡',
      received_count: 'å·²é¢†å–æ•°é‡',
      
      // å›¢é˜Ÿç›¸å…³
      team_name: 'å›¢é˜Ÿåç§°',
      member_count: 'æˆå‘˜æ•°é‡',
      total_performance: 'æ€»ä¸šç»©'
    };
    
    return columnNames[key] || key;
  }
  
  /**
   * è·å–åˆ—å®½åº¦
   */
  getColumnWidth(key) {
    const widthMap = {
      id: 10,
      username: 15,
      phone: 15,
      email: 20,
      address: 25,
      tx_hash: 25,
      created_at: 20,
      updated_at: 20,
      amount: 15,
      balance: 15
    };
    
    return widthMap[key] || 12;
  }
  
  /**
   * æ›´æ–°ä»»åŠ¡çŠ¶æ€
   */
  async updateTaskStatus(taskId, status, updates = {}) {
    const updateData = {
      status,
      ...updates
    };
    
    await this.db.query(
      'UPDATE export_tasks SET ? WHERE id = ?',
      [updateData, taskId]
    );
  }
  
  /**
   * æ›´æ–°ä»»åŠ¡è¿›åº¦
   */
  async updateTaskProgress(taskId, progress) {
    await this.db.query(
      'UPDATE export_tasks SET progress = ? WHERE id = ?',
      [progress, taskId]
    );
  }
  
  /**
   * ä¿å­˜å¯¼å‡ºä»»åŠ¡
   */
  async saveExportTask(task) {
    await this.db.query(`
      INSERT INTO export_tasks (
        id, user_id, module_type, module_name, format, filters,
        status, progress, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      task.id, task.userId, task.moduleType, task.moduleName,
      task.format, JSON.stringify(task.filters), task.status,
      task.progress, task.createdAt
    ]);
  }
}
```

## æ•°æ®å¯¼å…¥åŠŸèƒ½

### 1. æ•°æ®å¯¼å…¥ç®¡ç†å™¨

#### å¯¼å…¥æœåŠ¡æ ¸å¿ƒç±»
```javascript
/**
 * æ•°æ®å¯¼å…¥ç®¡ç†å™¨
 */
class DataImportManager {
  constructor(db, taskQueue, permissionService) {
    this.db = db;
    this.taskQueue = taskQueue;
    this.permissionService = permissionService;
    this.uploadPath = process.env.UPLOAD_PATH || './uploads';
    this.maxFileSize = 50 * 1024 * 1024; // 50MB
  }
  
  /**
   * åˆ›å»ºå¯¼å…¥ä»»åŠ¡
   */
  async createImportTask(userId, moduleType, file, options = {}) {
    // æƒé™éªŒè¯
    await this.permissionService.checkPermission(
      userId, 
      `import_${moduleType}`
    );
    
    const module = DATA_MODULES[moduleType];
    if (!module) {
      throw new Error(`ä¸æ”¯æŒçš„æ•°æ®æ¨¡å—: ${moduleType}`);
    }
    
    // æ–‡ä»¶éªŒè¯
    await this.validateImportFile(file, module);
    
    // ä¿å­˜ä¸Šä¼ æ–‡ä»¶
    const filePath = await this.saveUploadFile(file);
    
    // åˆ›å»ºå¯¼å…¥ä»»åŠ¡
    const taskId = `import_${moduleType}_${Date.now()}_${userId}`;
    const task = {
      id: taskId,
      userId,
      moduleType,
      moduleName: module.name,
      filePath,
      fileName: file.originalname,
      fileSize: file.size,
      options: options,
      status: 'pending',
      progress: 0,
      totalRecords: 0,
      processedRecords: 0,
      successRecords: 0,
      failedRecords: 0,
      validationErrors: [],
      createdAt: new Date(),
      startedAt: null,
      completedAt: null,
      error: null
    };
    
    // ä¿å­˜ä»»åŠ¡è®°å½•
    await this.saveImportTask(task);
    
    // æ·»åŠ åˆ°å¼‚æ­¥é˜Ÿåˆ—
    await this.taskQueue.add('data-import', task, {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 2000
      }
    });
    
    return {
      taskId,
      message: 'å¯¼å…¥ä»»åŠ¡å·²åˆ›å»ºï¼Œæ­£åœ¨å¤„ç†ä¸­...',
      estimatedTime: this.estimateImportTime(file.size)
    };
  }
  
  /**
   * æ‰§è¡Œæ•°æ®å¯¼å…¥
   */
  async executeImport(task) {
    try {
      await this.updateTaskStatus(task.id, 'processing', { startedAt: new Date() });
      
      // è§£ææ–‡ä»¶æ•°æ®
      const rawData = await this.parseImportFile(task);
      
      // æ•°æ®éªŒè¯
      const validationResult = await this.validateImportData(rawData, task);
      
      if (validationResult.errors.length > 0) {
        await this.updateTaskStatus(task.id, 'validation_failed', {
          validationErrors: validationResult.errors,
          completedAt: new Date()
        });
        return;
      }
      
      // æ•°æ®å¯¼å…¥
      const importResult = await this.importValidatedData(
        validationResult.validData, 
        task
      );
      
      // æ›´æ–°ä»»åŠ¡çŠ¶æ€
      await this.updateTaskStatus(task.id, 'completed', {
        totalRecords: rawData.length,
        processedRecords: importResult.processed,
        successRecords: importResult.success,
        failedRecords: importResult.failed,
        completedAt: new Date()
      });
      
      // å‘é€å®Œæˆé€šçŸ¥
      await this.notifyImportComplete(task, importResult);
      
    } catch (error) {
      await this.updateTaskStatus(task.id, 'failed', {
        error: error.message,
        completedAt: new Date()
      });
      
      throw error;
    }
  }
  
  /**
   * è§£æå¯¼å…¥æ–‡ä»¶
   */
  async parseImportFile(task) {
    const { filePath, fileName } = task;
    const fileExtension = path.extname(fileName).toLowerCase();
    
    switch (fileExtension) {
      case '.xlsx':
      case '.xls':
        return await this.parseExcelFile(filePath);
      case '.csv':
        return await this.parseCSVFile(filePath);
      case '.json':
        return await this.parseJSONFile(filePath);
      default:
        throw new Error(`ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: ${fileExtension}`);
    }
  }
  
  /**
   * è§£æExcelæ–‡ä»¶
   */
  async parseExcelFile(filePath) {
    const workbook = new ExcelJS.Workbook();
    await workbook.xlsx.readFile(filePath);
    
    const worksheet = workbook.getWorksheet(1);
    const data = [];
    
    // è·å–æ ‡é¢˜è¡Œ
    const headerRow = worksheet.getRow(1);
    const headers = [];
    
    headerRow.eachCell((cell, colNumber) => {
      headers[colNumber] = cell.value;
    });
    
    // è¯»å–æ•°æ®è¡Œ
    worksheet.eachRow((row, rowNumber) => {
      if (rowNumber === 1) return; // è·³è¿‡æ ‡é¢˜è¡Œ
      
      const record = {};
      row.eachCell((cell, colNumber) => {
        const header = headers[colNumber];
        if (header) {
          record[header] = cell.value;
        }
      });
      
      data.push(record);
    });
    
    return data;
  }
  
  /**
   * è§£æCSVæ–‡ä»¶
   */
  async parseCSVFile(filePath) {
    const csv = require('csv-parser');
    const fs = require('fs');
    
    return new Promise((resolve, reject) => {
      const results = [];
      
      fs.createReadStream(filePath)
        .pipe(csv())
        .on('data', (data) => results.push(data))
        .on('end', () => resolve(results))
        .on('error', reject);
    });
  }
  
  /**
   * è§£æJSONæ–‡ä»¶
   */
  async parseJSONFile(filePath) {
    const content = await fs.readFile(filePath, 'utf8');
    const jsonData = JSON.parse(content);
    
    // æ”¯æŒä¸¤ç§æ ¼å¼ï¼šç›´æ¥æ•°ç»„æˆ–åŒ…å«dataå­—æ®µçš„å¯¹è±¡
    return Array.isArray(jsonData) ? jsonData : jsonData.data || [];
  }
  
  /**
   * éªŒè¯å¯¼å…¥æ•°æ®
   */
  async validateImportData(data, task) {
    const { moduleType } = task;
    const errors = [];
    const validData = [];
    
    for (let i = 0; i < data.length; i++) {
      const record = data[i];
      const rowNumber = i + 2; // Excelè¡Œå·ï¼ˆåŒ…å«æ ‡é¢˜è¡Œï¼‰
      
      try {
        const validatedRecord = await this.validateRecord(record, moduleType, rowNumber);
        validData.push(validatedRecord);
      } catch (error) {
        errors.push({
          row: rowNumber,
          error: error.message,
          data: record
        });
      }
      
      // æ›´æ–°è¿›åº¦
      if (i % 100 === 0) {
        const progress = Math.floor((i / data.length) * 50); // éªŒè¯å 50%è¿›åº¦
        await this.updateTaskProgress(task.id, progress);
      }
    }
    
    return { validData, errors };
  }
  
  /**
   * éªŒè¯å•æ¡è®°å½•
   */
  async validateRecord(record, moduleType, rowNumber) {
    switch (moduleType) {
      case 'users':
        return await this.validateUserRecord(record, rowNumber);
      case 'wallets':
        return await this.validateWalletRecord(record, rowNumber);
      case 'transactions':
        return await this.validateTransactionRecord(record, rowNumber);
      default:
        return record;
    }
  }
  
  /**
   * éªŒè¯ç”¨æˆ·è®°å½•
   */
  async validateUserRecord(record, rowNumber) {
    const errors = [];
    
    // å¿…å¡«å­—æ®µéªŒè¯
    if (!record.username) {
      errors.push('ç”¨æˆ·åä¸èƒ½ä¸ºç©º');
    }
    
    if (!record.phone) {
      errors.push('æ‰‹æœºå·ä¸èƒ½ä¸ºç©º');
    } else if (!/^1[3-9]\d{9}$/.test(record.phone)) {
      errors.push('æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®');
    }
    
    if (record.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(record.email)) {
      errors.push('é‚®ç®±æ ¼å¼ä¸æ­£ç¡®');
    }
    
    // å”¯ä¸€æ€§éªŒè¯
    if (record.username) {
      const existingUser = await this.db.query(
        'SELECT id FROM users WHERE username = ? AND deleted_at IS NULL',
        [record.username]
      );
      
      if (existingUser.length > 0) {
        errors.push('ç”¨æˆ·åå·²å­˜åœ¨');
      }
    }
    
    if (record.phone) {
      const existingPhone = await this.db.query(
        'SELECT id FROM users WHERE phone = ? AND deleted_at IS NULL',
        [record.phone]
      );
      
      if (existingPhone.length > 0) {
        errors.push('æ‰‹æœºå·å·²å­˜åœ¨');
      }
    }
    
    if (errors.length > 0) {
      throw new Error(`ç¬¬${rowNumber}è¡Œ: ${errors.join(', ')}`);
    }
    
    return {
      username: record.username,
      phone: record.phone,
      email: record.email || null,
      status: record.status || 'active',
      level: parseInt(record.level) || 1,
      created_at: new Date()
    };
  }
  
  /**
   * å¯¼å…¥éªŒè¯åçš„æ•°æ®
   */
  async importValidatedData(data, task) {
    const { moduleType } = task;
    let processed = 0;
    let success = 0;
    let failed = 0;
    
    // å¼€å¯äº‹åŠ¡
    await this.db.beginTransaction();
    
    try {
      for (const record of data) {
        try {
          await this.importSingleRecord(record, moduleType);
          success++;
        } catch (error) {
          console.error(`å¯¼å…¥è®°å½•å¤±è´¥:`, error);
          failed++;
        }
        
        processed++;
        
        // æ›´æ–°è¿›åº¦
        if (processed % 100 === 0) {
          const progress = 50 + Math.floor((processed / data.length) * 50);
          await this.updateTaskProgress(task.id, progress);
        }
      }
      
      await this.db.commit();
      
    } catch (error) {
      await this.db.rollback();
      throw error;
    }
    
    return { processed, success, failed };
  }
  
  /**
   * å¯¼å…¥å•æ¡è®°å½•
   */
  async importSingleRecord(record, moduleType) {
    switch (moduleType) {
      case 'users':
        return await this.importUserRecord(record);
      case 'wallets':
        return await this.importWalletRecord(record);
      case 'transactions':
        return await this.importTransactionRecord(record);
      default:
        throw new Error(`ä¸æ”¯æŒçš„å¯¼å…¥æ¨¡å—: ${moduleType}`);
    }
  }
  
  /**
   * å¯¼å…¥ç”¨æˆ·è®°å½•
   */
  async importUserRecord(record) {
    const result = await this.db.query(`
      INSERT INTO users (username, phone, email, status, level, created_at)
      VALUES (?, ?, ?, ?, ?, ?)
    `, [
      record.username,
      record.phone,
      record.email,
      record.status,
      record.level,
      record.created_at
    ]);
    
    // åˆ›å»ºå¯¹åº”çš„é’±åŒ…
    if (result.insertId) {
      await this.createUserWallet(result.insertId);
    }
    
    return result.insertId;
  }
  
  /**
   * æ–‡ä»¶éªŒè¯
   */
  async validateImportFile(file, module) {
    // æ–‡ä»¶å¤§å°éªŒè¯
    if (file.size > this.maxFileSize) {
      throw new Error(`æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶ (${this.maxFileSize / 1024 / 1024}MB)`);
    }
    
    // æ–‡ä»¶æ ¼å¼éªŒè¯
    const allowedExtensions = ['.xlsx', '.xls', '.csv', '.json'];
    const fileExtension = path.extname(file.originalname).toLowerCase();
    
    if (!allowedExtensions.includes(fileExtension)) {
      throw new Error(`ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: ${fileExtension}`);
    }
    
    // æ–‡ä»¶å†…å®¹éªŒè¯ï¼ˆæ£€æŸ¥æ˜¯å¦ä¸ºç©ºæ–‡ä»¶ï¼‰
    if (file.size === 0) {
      throw new Error('æ–‡ä»¶å†…å®¹ä¸ºç©º');
    }
  }
  
  /**
   * ä¿å­˜ä¸Šä¼ æ–‡ä»¶
   */
  async saveUploadFile(file) {
    const timestamp = Date.now();
    const filename = `${timestamp}_${file.originalname}`;
    const filePath = path.join(this.uploadPath, filename);
    
    // ç¡®ä¿ä¸Šä¼ ç›®å½•å­˜åœ¨
    await fs.mkdir(this.uploadPath, { recursive: true });
    
    // ä¿å­˜æ–‡ä»¶
    await fs.writeFile(filePath, file.buffer);
    
    return filePath;
  }
}
```

## APIæ¥å£è®¾è®¡

### 1. å¯¼å‡ºæ¥å£

#### å¯¼å‡ºç›¸å…³API
```javascript
/**
 * æ•°æ®å¯¼å‡ºAPIè·¯ç”±
 */
const express = require('express');
const router = express.Router();
const multer = require('multer');
const { body, query, validationResult } = require('express-validator');

// ä¸­é—´ä»¶
const authMiddleware = require('../middleware/auth');
const permissionMiddleware = require('../middleware/permission');
const rateLimitMiddleware = require('../middleware/rateLimit');

// æœåŠ¡
const dataExportManager = new DataExportManager(db, taskQueue, permissionService);
const dataImportManager = new DataImportManager(db, taskQueue, permissionService);

/**
 * åˆ›å»ºå¯¼å‡ºä»»åŠ¡
 * POST /api/admin/export/create
 */
router.post('/create',
  authMiddleware,
  rateLimitMiddleware({ windowMs: 60000, max: 10 }), // 1åˆ†é’Ÿ10æ¬¡
  [
    body('moduleType').isIn(Object.keys(DATA_MODULES)).withMessage('æ— æ•ˆçš„æ•°æ®æ¨¡å—'),
    body('format').isIn(['excel', 'csv', 'json', 'pdf']).withMessage('æ— æ•ˆçš„å¯¼å‡ºæ ¼å¼'),
    body('filters').optional().isObject().withMessage('è¿‡æ»¤æ¡ä»¶å¿…é¡»æ˜¯å¯¹è±¡'),
    body('columns').optional().isArray().withMessage('åˆ—é…ç½®å¿…é¡»æ˜¯æ•°ç»„')
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'å‚æ•°éªŒè¯å¤±è´¥',
          errors: errors.array()
        });
      }
      
      const { moduleType, format, filters, columns } = req.body;
      const userId = req.user.id;
      
      const result = await dataExportManager.createExportTask(userId, moduleType, {
        format,
        filters,
        columns
      });
      
      res.json({
        success: true,
        data: result
      });
      
    } catch (error) {
      console.error('åˆ›å»ºå¯¼å‡ºä»»åŠ¡å¤±è´¥:', error);
      res.status(500).json({
        success: false,
        message: error.message
      });
    }
  }
);

/**
 * è·å–å¯¼å‡ºä»»åŠ¡åˆ—è¡¨
 * GET /api/admin/export/tasks
 */
router.get('/tasks',
  authMiddleware,
  [
    query('page').optional().isInt({ min: 1 }).withMessage('é¡µç å¿…é¡»æ˜¯æ­£æ•´æ•°'),
    query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('æ¯é¡µæ•°é‡å¿…é¡»åœ¨1-100ä¹‹é—´'),
    query('status').optional().isIn(['pending', 'processing', 'completed', 'failed']).withMessage('æ— æ•ˆçš„çŠ¶æ€')
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'å‚æ•°éªŒè¯å¤±è´¥',
          errors: errors.array()
        });
      }
      
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const status = req.query.status;
      const userId = req.user.id;
      
      // æ„å»ºæŸ¥è¯¢æ¡ä»¶
      let whereClause = 'WHERE user_id = ?';
      const params = [userId];
      
      if (status) {
        whereClause += ' AND status = ?';
        params.push(status);
      }
      
      // è·å–æ€»æ•°
      const [countResult] = await db.query(
        `SELECT COUNT(*) as total FROM export_tasks ${whereClause}`,
        params
      );
      
      // è·å–ä»»åŠ¡åˆ—è¡¨
      const tasks = await db.query(`
        SELECT 
          id, module_type, module_name, format, status, progress,
          total_records, file_size, created_at, completed_at, error
        FROM export_tasks 
        ${whereClause}
        ORDER BY created_at DESC
        LIMIT ? OFFSET ?
      `, [...params, limit, (page - 1) * limit]);
      
      res.json({
        success: true,
        data: {
          tasks,
          pagination: {
            page,
            limit,
            total: countResult.total,
            pages: Math.ceil(countResult.total / limit)
          }
        }
      });
      
    } catch (error) {
      console.error('è·å–å¯¼å‡ºä»»åŠ¡åˆ—è¡¨å¤±è´¥:', error);
      res.status(500).json({
        success: false,
        message: 'è·å–ä»»åŠ¡åˆ—è¡¨å¤±è´¥'
      });
    }
  }
);

/**
 * ä¸‹è½½å¯¼å‡ºæ–‡ä»¶
 * GET /api/admin/export/download/:taskId
 */
router.get('/download/:taskId',
  authMiddleware,
  async (req, res) => {
    try {
      const { taskId } = req.params;
      const userId = req.user.id;
      
      // è·å–ä»»åŠ¡ä¿¡æ¯
      const [task] = await db.query(`
        SELECT file_path, file_name, status, user_id
        FROM export_tasks 
        WHERE id = ?
      `, [taskId]);
      
      if (!task) {
        return res.status(404).json({
          success: false,
          message: 'å¯¼å‡ºä»»åŠ¡ä¸å­˜åœ¨'
        });
      }
      
      // æƒé™éªŒè¯
      if (task.user_id !== userId && !req.user.permissions.includes('admin')) {
        return res.status(403).json({
          success: false,
          message: 'æ— æƒé™ä¸‹è½½æ­¤æ–‡ä»¶'
        });
      }
      
      if (task.status !== 'completed') {
        return res.status(400).json({
          success: false,
          message: 'æ–‡ä»¶å°šæœªç”Ÿæˆå®Œæˆ'
        });
      }
      
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      if (!await fs.access(task.file_path).then(() => true).catch(() => false)) {
        return res.status(404).json({
          success: false,
          message: 'æ–‡ä»¶ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ'
        });
      }
      
      // è®¾ç½®ä¸‹è½½å¤´
      res.setHeader('Content-Disposition', `attachment; filename="${task.file_name}"`);
      res.setHeader('Content-Type', 'application/octet-stream');
      
      // å‘é€æ–‡ä»¶
      res.sendFile(path.resolve(task.file_path));
      
    } catch (error) {
      console.error('ä¸‹è½½å¯¼å‡ºæ–‡ä»¶å¤±è´¥:', error);
      res.status(500).json({
        success: false,
        message: 'ä¸‹è½½æ–‡ä»¶å¤±è´¥'
      });
    }
  }
);
```

### 2. å¯¼å…¥æ¥å£

#### å¯¼å…¥ç›¸å…³API
```javascript
/**
 * æ–‡ä»¶ä¸Šä¼ é…ç½®
 */
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 50 * 1024 * 1024 // 50MB
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = [
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'application/vnd.ms-excel',
      'text/csv',
      'application/json'
    ];
    
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹'), false);
    }
  }
});

/**
 * åˆ›å»ºå¯¼å…¥ä»»åŠ¡
 * POST /api/admin/import/create
 */
router.post('/create',
  authMiddleware,
  upload.single('file'),
  rateLimitMiddleware({ windowMs: 60000, max: 5 }), // 1åˆ†é’Ÿ5æ¬¡
  [
    body('moduleType').isIn(Object.keys(DATA_MODULES)).withMessage('æ— æ•ˆçš„æ•°æ®æ¨¡å—'),
    body('options').optional().isObject().withMessage('é€‰é¡¹å¿…é¡»æ˜¯å¯¹è±¡')
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'å‚æ•°éªŒè¯å¤±è´¥',
          errors: errors.array()
        });
      }
      
      if (!req.file) {
        return res.status(400).json({
          success: false,
          message: 'è¯·é€‰æ‹©è¦å¯¼å…¥çš„æ–‡ä»¶'
        });
      }
      
      const { moduleType, options } = req.body;
      const userId = req.user.id;
      
      const result = await dataImportManager.createImportTask(
        userId, 
        moduleType, 
        req.file, 
        JSON.parse(options || '{}')
      );
      
      res.json({
        success: true,
        data: result
      });
      
    } catch (error) {
      console.error('åˆ›å»ºå¯¼å…¥ä»»åŠ¡å¤±è´¥:', error);
      res.status(500).json({
        success: false,
        message: error.message
      });
    }
  }
);

/**
 * è·å–å¯¼å…¥ä»»åŠ¡è¯¦æƒ…
 * GET /api/admin/import/task/:taskId
 */
router.get('/task/:taskId',
  authMiddleware,
  async (req, res) => {
    try {
      const { taskId } = req.params;
      const userId = req.user.id;
      
      const [task] = await db.query(`
        SELECT 
          id, module_type, module_name, file_name, file_size,
          status, progress, total_records, processed_records,
          success_records, failed_records, validation_errors,
          created_at, started_at, completed_at, error
        FROM import_tasks 
        WHERE id = ? AND user_id = ?
      `, [taskId, userId]);
      
      if (!task) {
        return res.status(404).json({
          success: false,
          message: 'å¯¼å…¥ä»»åŠ¡ä¸å­˜åœ¨'
        });
      }
      
      // è§£æéªŒè¯é”™è¯¯
      if (task.validation_errors) {
        task.validation_errors = JSON.parse(task.validation_errors);
      }
      
      res.json({
        success: true,
        data: task
      });
      
    } catch (error) {
      console.error('è·å–å¯¼å…¥ä»»åŠ¡è¯¦æƒ…å¤±è´¥:', error);
      res.status(500).json({
        success: false,
        message: 'è·å–ä»»åŠ¡è¯¦æƒ…å¤±è´¥'
      });
    }
  }
);

/**
 * è·å–æ•°æ®æ¨¡æ¿
 * GET /api/admin/import/template/:moduleType
 */
router.get('/template/:moduleType',
  authMiddleware,
  async (req, res) => {
    try {
      const { moduleType } = req.params;
      
      if (!DATA_MODULES[moduleType]) {
        return res.status(400).json({
          success: false,
          message: 'æ— æ•ˆçš„æ•°æ®æ¨¡å—'
        });
      }
      
      const template = await generateImportTemplate(moduleType);
      
      res.setHeader('Content-Disposition', `attachment; filename="${moduleType}_template.xlsx"`);
      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      
      await template.xlsx.write(res);
      res.end();
      
    } catch (error) {
      console.error('ç”Ÿæˆå¯¼å…¥æ¨¡æ¿å¤±è´¥:', error);
      res.status(500).json({
        success: false,
        message: 'ç”Ÿæˆæ¨¡æ¿å¤±è´¥'
      });
    }
  }
);

/**
 * ç”Ÿæˆå¯¼å…¥æ¨¡æ¿
 */
async function generateImportTemplate(moduleType) {
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet('å¯¼å…¥æ¨¡æ¿');
  
  // æ ¹æ®æ¨¡å—ç±»å‹è®¾ç½®åˆ—
  let columns = [];
  
  switch (moduleType) {
    case 'users':
      columns = [
        { header: 'ç”¨æˆ·å*', key: 'username', width: 15 },
        { header: 'æ‰‹æœºå·*', key: 'phone', width: 15 },
        { header: 'é‚®ç®±', key: 'email', width: 20 },
        { header: 'çŠ¶æ€', key: 'status', width: 10 },
        { header: 'ç­‰çº§', key: 'level', width: 10 }
      ];
      break;
    case 'transactions':
      columns = [
        { header: 'ç”¨æˆ·ID*', key: 'user_id', width: 10 },
        { header: 'äº¤æ˜“ç±»å‹*', key: 'type', width: 15 },
        { header: 'é‡‘é¢*', key: 'amount', width: 15 },
        { header: 'æ‰‹ç»­è´¹', key: 'fee', width: 10 },
        { header: 'çŠ¶æ€*', key: 'status', width: 10 }
      ];
      break;
    default:
      columns = [
        { header: 'ç¤ºä¾‹åˆ—1', key: 'column1', width: 15 },
        { header: 'ç¤ºä¾‹åˆ—2', key: 'column2', width: 15 }
      ];
  }
  
  worksheet.columns = columns;
  
  // è®¾ç½®æ ‡é¢˜æ ·å¼
  worksheet.getRow(1).font = { bold: true };
  worksheet.getRow(1).fill = {
    type: 'pattern',
    pattern: 'solid',
    fgColor: { argb: 'FFE0E0E0' }
  };
  
  // æ·»åŠ è¯´æ˜è¡Œ
  worksheet.addRow([]);
  worksheet.addRow(['è¯´æ˜ï¼š']);
  worksheet.addRow(['1. å¸¦*å·çš„åˆ—ä¸ºå¿…å¡«é¡¹']);
  worksheet.addRow(['2. è¯·ä¸¥æ ¼æŒ‰ç…§æ¨¡æ¿æ ¼å¼å¡«å†™æ•°æ®']);
  worksheet.addRow(['3. å¯¼å…¥å‰è¯·åˆ é™¤æ­¤è¯´æ˜éƒ¨åˆ†']);
  
  return workbook;
}

module.exports = router;
```

## æ•°æ®åº“è®¾è®¡

### 1. å¯¼å…¥å¯¼å‡ºä»»åŠ¡è¡¨

#### è¡¨ç»“æ„è®¾è®¡
```sql
-- å¯¼å‡ºä»»åŠ¡è¡¨
CREATE TABLE export_tasks (
  id VARCHAR(100) PRIMARY KEY COMMENT 'ä»»åŠ¡ID',
  user_id INT NOT NULL COMMENT 'ç”¨æˆ·ID',
  module_type VARCHAR(50) NOT NULL COMMENT 'æ•°æ®æ¨¡å—ç±»å‹',
  module_name VARCHAR(100) NOT NULL COMMENT 'æ•°æ®æ¨¡å—åç§°',
  format VARCHAR(20) NOT NULL COMMENT 'å¯¼å‡ºæ ¼å¼',
  filters JSON COMMENT 'è¿‡æ»¤æ¡ä»¶',
  columns JSON COMMENT 'å¯¼å‡ºåˆ—é…ç½®',
  status ENUM('pending', 'processing', 'completed', 'failed') DEFAULT 'pending' COMMENT 'ä»»åŠ¡çŠ¶æ€',
  progress INT DEFAULT 0 COMMENT 'è¿›åº¦ç™¾åˆ†æ¯”',
  total_records INT DEFAULT 0 COMMENT 'æ€»è®°å½•æ•°',
  processed_records INT DEFAULT 0 COMMENT 'å·²å¤„ç†è®°å½•æ•°',
  file_path VARCHAR(500) COMMENT 'æ–‡ä»¶è·¯å¾„',
  file_size BIGINT DEFAULT 0 COMMENT 'æ–‡ä»¶å¤§å°',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
  started_at TIMESTAMP NULL COMMENT 'å¼€å§‹æ—¶é—´',
  completed_at TIMESTAMP NULL COMMENT 'å®Œæˆæ—¶é—´',
  error TEXT COMMENT 'é”™è¯¯ä¿¡æ¯',
  INDEX idx_user_id (user_id),
  INDEX idx_status (status),
  INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='æ•°æ®å¯¼å‡ºä»»åŠ¡è¡¨';

-- å¯¼å…¥ä»»åŠ¡è¡¨
CREATE TABLE import_tasks (
  id VARCHAR(100) PRIMARY KEY COMMENT 'ä»»åŠ¡ID',
  user_id INT NOT NULL COMMENT 'ç”¨æˆ·ID',
  module_type VARCHAR(50) NOT NULL COMMENT 'æ•°æ®æ¨¡å—ç±»å‹',
  module_name VARCHAR(100) NOT NULL COMMENT 'æ•°æ®æ¨¡å—åç§°',
  file_path VARCHAR(500) NOT NULL COMMENT 'æ–‡ä»¶è·¯å¾„',
  file_name VARCHAR(200) NOT NULL COMMENT 'æ–‡ä»¶å',
  file_size BIGINT NOT NULL COMMENT 'æ–‡ä»¶å¤§å°',
  options JSON COMMENT 'å¯¼å…¥é€‰é¡¹',
  status ENUM('pending', 'processing', 'validation_failed', 'completed', 'failed') DEFAULT 'pending' COMMENT 'ä»»åŠ¡çŠ¶æ€',
  progress INT DEFAULT 0 COMMENT 'è¿›åº¦ç™¾åˆ†æ¯”',
  total_records INT DEFAULT 0 COMMENT 'æ€»è®°å½•æ•°',
  processed_records INT DEFAULT 0 COMMENT 'å·²å¤„ç†è®°å½•æ•°',
  success_records INT DEFAULT 0 COMMENT 'æˆåŠŸè®°å½•æ•°',
  failed_records INT DEFAULT 0 COMMENT 'å¤±è´¥è®°å½•æ•°',
  validation_errors JSON COMMENT 'éªŒè¯é”™è¯¯',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
  started_at TIMESTAMP NULL COMMENT 'å¼€å§‹æ—¶é—´',
  completed_at TIMESTAMP NULL COMMENT 'å®Œæˆæ—¶é—´',
  error TEXT COMMENT 'é”™è¯¯ä¿¡æ¯',
  INDEX idx_user_id (user_id),
  INDEX idx_status (status),
  INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='æ•°æ®å¯¼å…¥ä»»åŠ¡è¡¨';

-- å¯¼å…¥å¯¼å‡ºæ“ä½œæ—¥å¿—è¡¨
CREATE TABLE import_export_logs (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  task_id VARCHAR(100) NOT NULL COMMENT 'ä»»åŠ¡ID',
  task_type ENUM('import', 'export') NOT NULL COMMENT 'ä»»åŠ¡ç±»å‹',
  user_id INT NOT NULL COMMENT 'æ“ä½œç”¨æˆ·ID',
  operation VARCHAR(50) NOT NULL COMMENT 'æ“ä½œç±»å‹',
  details JSON COMMENT 'æ“ä½œè¯¦æƒ…',
  ip_address VARCHAR(45) COMMENT 'IPåœ°å€',
  user_agent TEXT COMMENT 'ç”¨æˆ·ä»£ç†',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
  INDEX idx_task_id (task_id),
  INDEX idx_user_id (user_id),
  INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='å¯¼å…¥å¯¼å‡ºæ“ä½œæ—¥å¿—è¡¨';
```

## å‰ç«¯ç•Œé¢è®¾è®¡

### 1. æ•°æ®å¯¼å‡ºç•Œé¢

#### Reactå¯¼å‡ºç»„ä»¶
```jsx
/**
 * æ•°æ®å¯¼å‡ºç»„ä»¶
 */
import React, { useState, useEffect } from 'react';
import { 
  Card, 
  Form, 
  Select, 
  Button, 
  DatePicker, 
  InputNumber, 
  Checkbox, 
  Table, 
  Progress, 
  message, 
  Modal 
} from 'antd';
import { DownloadOutlined, ExportOutlined } from '@ant-design/icons';

const { RangePicker } = DatePicker;
const { Option } = Select;

const DataExportPage = () => {
  const [form] = Form.useForm();
  const [loading, setLoading] = useState(false);
  const [exportTasks, setExportTasks] = useState([]);
  const [selectedModule, setSelectedModule] = useState('');
  
  // æ•°æ®æ¨¡å—é…ç½®
  const dataModules = {
    users: { name: 'ç”¨æˆ·æ•°æ®', icon: 'ğŸ‘¥' },
    wallets: { name: 'é’±åŒ…æ•°æ®', icon: 'ğŸ’°' },
    transactions: { name: 'äº¤æ˜“è®°å½•', icon: 'ğŸ’³' },
    tasks: { name: 'ä»»åŠ¡æ•°æ®', icon: 'ğŸ“‹' },
    redPackets: { name: 'çº¢åŒ…è®°å½•', icon: 'ğŸ§§' },
    teams: { name: 'å›¢é˜Ÿæ•°æ®', icon: 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦' },
    rankings: { name: 'æ’è¡Œæ¦œæ•°æ®', icon: 'ğŸ†' },
    systemLogs: { name: 'ç³»ç»Ÿæ—¥å¿—', icon: 'ğŸ“' }
  };
  
  // å¯¼å‡ºæ ¼å¼é€‰é¡¹
  const formatOptions = [
    { value: 'excel', label: 'Excel (.xlsx)', icon: 'ğŸ“Š' },
    { value: 'csv', label: 'CSV (.csv)', icon: 'ğŸ“„' },
    { value: 'json', label: 'JSON (.json)', icon: 'ğŸ”§' },
    { value: 'pdf', label: 'PDF (.pdf)', icon: 'ğŸ“‘' }
  ];
  
  useEffect(() => {
    loadExportTasks();
    
    // å®šæ—¶åˆ·æ–°ä»»åŠ¡çŠ¶æ€
    const interval = setInterval(loadExportTasks, 5000);
    return () => clearInterval(interval);
  }, []);
  
  /**
   * åŠ è½½å¯¼å‡ºä»»åŠ¡åˆ—è¡¨
   */
  const loadExportTasks = async () => {
    try {
      const response = await fetch('/api/admin/export/tasks');
      const result = await response.json();
      
      if (result.success) {
        setExportTasks(result.data.tasks);
      }
    } catch (error) {
      console.error('åŠ è½½å¯¼å‡ºä»»åŠ¡å¤±è´¥:', error);
    }
  };
  
  /**
   * åˆ›å»ºå¯¼å‡ºä»»åŠ¡
   */
  const handleExport = async (values) => {
    setLoading(true);
    
    try {
      const response = await fetch('/api/admin/export/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(values)
      });
      
      const result = await response.json();
      
      if (result.success) {
        message.success('å¯¼å‡ºä»»åŠ¡å·²åˆ›å»ºï¼Œæ­£åœ¨å¤„ç†ä¸­...');
        form.resetFields();
        loadExportTasks();
      } else {
        message.error(result.message || 'åˆ›å»ºå¯¼å‡ºä»»åŠ¡å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ›å»ºå¯¼å‡ºä»»åŠ¡å¤±è´¥:', error);
      message.error('åˆ›å»ºå¯¼å‡ºä»»åŠ¡å¤±è´¥');
    } finally {
      setLoading(false);
    }
  };
  
  /**
   * ä¸‹è½½å¯¼å‡ºæ–‡ä»¶
   */
  const handleDownload = async (taskId) => {
    try {
      const response = await fetch(`/api/admin/export/download/${taskId}`);
      
      if (response.ok) {
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = response.headers.get('Content-Disposition')?.split('filename=')[1] || 'export.xlsx';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
      } else {
        const result = await response.json();
        message.error(result.message || 'ä¸‹è½½å¤±è´¥');
      }
    } catch (error) {
      console.error('ä¸‹è½½æ–‡ä»¶å¤±è´¥:', error);
      message.error('ä¸‹è½½æ–‡ä»¶å¤±è´¥');
    }
  };
  
  /**
   * æ¸²æŸ“è¿‡æ»¤æ¡ä»¶è¡¨å•
   */
  const renderFilterForm = () => {
    if (!selectedModule) return null;
    
    switch (selectedModule) {
      case 'users':
        return (
          <>
            <Form.Item name={['filters', 'status']} label="ç”¨æˆ·çŠ¶æ€">
              <Select placeholder="é€‰æ‹©ç”¨æˆ·çŠ¶æ€" allowClear>
                <Option value="active">æ´»è·ƒ</Option>
                <Option value="inactive">éæ´»è·ƒ</Option>
                <Option value="suspended">å·²æš‚åœ</Option>
              </Select>
            </Form.Item>
            <Form.Item name={['filters', 'level']} label="ç”¨æˆ·ç­‰çº§">
              <InputNumber placeholder="ç”¨æˆ·ç­‰çº§" min={1} max={10} />
            </Form.Item>
            <Form.Item name={['filters', 'dateRange']} label="æ³¨å†Œæ—¶é—´">
              <RangePicker showTime />
            </Form.Item>
            <Form.Item name={['filters', 'minBalance']} label="æœ€å°ä½™é¢">
              <InputNumber placeholder="æœ€å°ä½™é¢" min={0} precision={2} />
            </Form.Item>
          </>
        );
      case 'transactions':
        return (
          <>
            <Form.Item name={['filters', 'type']} label="äº¤æ˜“ç±»å‹">
              <Select placeholder="é€‰æ‹©äº¤æ˜“ç±»å‹" allowClear>
                <Option value="deposit">å……å€¼</Option>
                <Option value="withdraw">æç°</Option>
                <Option value="transfer">è½¬è´¦</Option>
                <Option value="reward">å¥–åŠ±</Option>
              </Select>
            </Form.Item>
            <Form.Item name={['filters', 'status']} label="äº¤æ˜“çŠ¶æ€">
              <Select placeholder="é€‰æ‹©äº¤æ˜“çŠ¶æ€" allowClear>
                <Option value="pending">å¾…å¤„ç†</Option>
                <Option value="confirmed">å·²ç¡®è®¤</Option>
                <Option value="failed">å¤±è´¥</Option>
              </Select>
            </Form.Item>
            <Form.Item name={['filters', 'dateRange']} label="äº¤æ˜“æ—¶é—´">
              <RangePicker showTime />
            </Form.Item>
            <Form.Item name={['filters', 'minAmount']} label="æœ€å°é‡‘é¢">
              <InputNumber placeholder="æœ€å°é‡‘é¢" min={0} precision={2} />
            </Form.Item>
          </>
        );
      default:
        return (
          <Form.Item name={['filters', 'dateRange']} label="æ—¶é—´èŒƒå›´">
            <RangePicker showTime />
          </Form.Item>
        );
    }
  };
  
  // ä»»åŠ¡çŠ¶æ€åˆ—é…ç½®
  const taskColumns = [
    {
      title: 'æ¨¡å—',
      dataIndex: 'module_name',
      key: 'module_name',
      render: (text, record) => (
        <span>
          {dataModules[record.module_type]?.icon} {text}
        </span>
      )
    },
    {
      title: 'æ ¼å¼',
      dataIndex: 'format',
      key: 'format',
      render: (format) => {
        const option = formatOptions.find(opt => opt.value === format);
        return option ? `${option.icon} ${option.label}` : format;
      }
    },
    {
      title: 'çŠ¶æ€',
      dataIndex: 'status',
      key: 'status',
      render: (status) => {
        const statusMap = {
          pending: { color: '#faad14', text: 'ç­‰å¾…ä¸­' },
          processing: { color: '#1890ff', text: 'å¤„ç†ä¸­' },
          completed: { color: '#52c41a', text: 'å·²å®Œæˆ' },
          failed: { color: '#ff4d4f', text: 'å¤±è´¥' }
        };
        
        const statusInfo = statusMap[status] || { color: '#d9d9d9', text: status };
        
        return (
          <span style={{ color: statusInfo.color }}>
            â— {statusInfo.text}
          </span>
        );
      }
    },
    {
      title: 'è¿›åº¦',
      dataIndex: 'progress',
      key: 'progress',
      render: (progress, record) => (
        record.status === 'processing' ? (
          <Progress percent={progress} size="small" />
        ) : (
          record.status === 'completed' ? '100%' : '-'
        )
      )
    },
    {
      title: 'è®°å½•æ•°',
      dataIndex: 'total_records',
      key: 'total_records',
      render: (count) => count ? count.toLocaleString() : '-'
    },
    {
      title: 'æ–‡ä»¶å¤§å°',
      dataIndex: 'file_size',
      key: 'file_size',
      render: (size) => {
        if (!size) return '-';
        if (size < 1024) return `${size} B`;
        if (size < 1024 * 1024) return `${(size / 1024).toFixed(1)} KB`;
        return `${(size / 1024 / 1024).toFixed(1)} MB`;
      }
    },
    {
      title: 'åˆ›å»ºæ—¶é—´',
      dataIndex: 'created_at',
      key: 'created_at',
      render: (time) => new Date(time).toLocaleString()
    },
    {
      title: 'æ“ä½œ',
      key: 'action',
      render: (_, record) => (
        record.status === 'completed' ? (
          <Button
            type="link"
            icon={<DownloadOutlined />}
            onClick={() => handleDownload(record.id)}
          >
            ä¸‹è½½
          </Button>
        ) : record.status === 'failed' ? (
          <span style={{ color: '#ff4d4f' }}>{record.error}</span>
        ) : null
      )
    }
  ];
  
  return (
    <div className="data-export-page">
      <Card title="ğŸ“¤ æ•°æ®å¯¼å‡º" style={{ marginBottom: 24 }}>
        <Form
          form={form}
          layout="vertical"
          onFinish={handleExport}
        >
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: 16 }}>
            <Form.Item
              name="moduleType"
              label="æ•°æ®æ¨¡å—"
              rules={[{ required: true, message: 'è¯·é€‰æ‹©æ•°æ®æ¨¡å—' }]}
            >
              <Select
                placeholder="é€‰æ‹©è¦å¯¼å‡ºçš„æ•°æ®æ¨¡å—"
                onChange={setSelectedModule}
              >
                {Object.entries(dataModules).map(([key, module]) => (
                  <Option key={key} value={key}>
                    {module.icon} {module.name}
                  </Option>
                ))}
              </Select>
            </Form.Item>
            
            <Form.Item
              name="format"
              label="å¯¼å‡ºæ ¼å¼"
              rules={[{ required: true, message: 'è¯·é€‰æ‹©å¯¼å‡ºæ ¼å¼' }]}
            >
              <Select placeholder="é€‰æ‹©å¯¼å‡ºæ ¼å¼">
                {formatOptions.map(option => (
                  <Option key={option.value} value={option.value}>
                    {option.icon} {option.label}
                  </Option>
                ))}
              </Select>
            </Form.Item>
          </div>
          
          {renderFilterForm()}
          
          <Form.Item name={['filters', 'limit']} label="å¯¼å‡ºæ•°é‡é™åˆ¶">
            <InputNumber
              placeholder="æœ€å¤§å¯¼å‡ºè®°å½•æ•°ï¼ˆç•™ç©ºè¡¨ç¤ºå…¨éƒ¨ï¼‰"
              min={1}
              max={1000000}
              style={{ width: '100%' }}
            />
          </Form.Item>
          
          <Form.Item>
            <Button
              type="primary"
              htmlType="submit"
              icon={<ExportOutlined />}
              loading={loading}
              size="large"
            >
              åˆ›å»ºå¯¼å‡ºä»»åŠ¡
            </Button>
          </Form.Item>
        </Form>
      </Card>
      
      <Card title="ğŸ“‹ å¯¼å‡ºä»»åŠ¡åˆ—è¡¨">
        <Table
          columns={taskColumns}
          dataSource={exportTasks}
          rowKey="id"
          pagination={{
            pageSize: 10,
            showSizeChanger: true,
            showQuickJumper: true,
            showTotal: (total) => `å…± ${total} æ¡è®°å½•`
          }}
        />
      </Card>
    </div>
  );
};

export default DataExportPage;
```

### 2. æ•°æ®å¯¼å…¥ç•Œé¢

#### Reactå¯¼å…¥ç»„ä»¶
```jsx
/**
 * æ•°æ®å¯¼å…¥ç»„ä»¶
 */
import React, { useState, useEffect } from 'react';
import { 
  Card, 
  Upload, 
  Button, 
  Select, 
  Table, 
  Progress, 
  message, 
  Modal, 
  Alert,
  Steps,
  Descriptions
} from 'antd';
import { 
  InboxOutlined, 
  UploadOutlined, 
  DownloadOutlined,
  CheckCircleOutlined,
  ExclamationCircleOutlined
} from '@ant-design/icons';

const { Dragger } = Upload;
const { Option } = Select;
const { Step } = Steps;

const DataImportPage = () => {
  const [selectedModule, setSelectedModule] = useState('');
  const [uploadFile, setUploadFile] = useState(null);
  const [importing, setImporting] = useState(false);
  const [importTasks, setImportTasks] = useState([]);
  const [taskDetailModal, setTaskDetailModal] = useState({ visible: false, task: null });
  
  // æ•°æ®æ¨¡å—é…ç½®
  const dataModules = {
    users: { 
      name: 'ç”¨æˆ·æ•°æ®', 
      icon: 'ğŸ‘¥',
      description: 'æ‰¹é‡å¯¼å…¥ç”¨æˆ·åŸºæœ¬ä¿¡æ¯',
      maxRecords: 10000,
      requiredFields: ['username', 'phone']
    },
    wallets: { 
      name: 'é’±åŒ…æ•°æ®', 
      icon: 'ğŸ’°',
      description: 'æ‰¹é‡å¯¼å…¥é’±åŒ…ä¿¡æ¯',
      maxRecords: 50000,
      requiredFields: ['user_id', 'address']
    },
    transactions: { 
      name: 'äº¤æ˜“è®°å½•', 
      icon: 'ğŸ’³',
      description: 'æ‰¹é‡å¯¼å…¥äº¤æ˜“æ•°æ®',
      maxRecords: 100000,
      requiredFields: ['user_id', 'type', 'amount']
    }
  };
  
  useEffect(() => {
    loadImportTasks();
    
    // å®šæ—¶åˆ·æ–°ä»»åŠ¡çŠ¶æ€
    const interval = setInterval(loadImportTasks, 5000);
    return () => clearInterval(interval);
  }, []);
  
  /**
   * åŠ è½½å¯¼å…¥ä»»åŠ¡åˆ—è¡¨
   */
  const loadImportTasks = async () => {
    try {
      const response = await fetch('/api/admin/import/tasks');
      const result = await response.json();
      
      if (result.success) {
        setImportTasks(result.data.tasks);
      }
    } catch (error) {
      console.error('åŠ è½½å¯¼å…¥ä»»åŠ¡å¤±è´¥:', error);
    }
  };
  
  /**
   * ä¸‹è½½å¯¼å…¥æ¨¡æ¿
   */
  const handleDownloadTemplate = async () => {
    if (!selectedModule) {
      message.warning('è¯·å…ˆé€‰æ‹©æ•°æ®æ¨¡å—');
      return;
    }
    
    try {
      const response = await fetch(`/api/admin/import/template/${selectedModule}`);
      
      if (response.ok) {
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${selectedModule}_template.xlsx`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
        
        message.success('æ¨¡æ¿ä¸‹è½½æˆåŠŸ');
      } else {
        message.error('ä¸‹è½½æ¨¡æ¿å¤±è´¥');
      }
    } catch (error) {
      console.error('ä¸‹è½½æ¨¡æ¿å¤±è´¥:', error);
      message.error('ä¸‹è½½æ¨¡æ¿å¤±è´¥');
    }
  };
  
  /**
   * æ–‡ä»¶ä¸Šä¼ é…ç½®
   */
  const uploadProps = {
    name: 'file',
    multiple: false,
    accept: '.xlsx,.xls,.csv,.json',
    beforeUpload: (file) => {
      // æ–‡ä»¶å¤§å°éªŒè¯
      const isLt50M = file.size / 1024 / 1024 < 50;
      if (!isLt50M) {
        message.error('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡ 50MB');
        return false;
      }
      
      // æ–‡ä»¶æ ¼å¼éªŒè¯
      const allowedTypes = [
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-excel',
        'text/csv',
        'application/json'
      ];
      
      if (!allowedTypes.includes(file.type)) {
        message.error('åªæ”¯æŒ Excelã€CSVã€JSON æ ¼å¼æ–‡ä»¶');
        return false;
      }
      
      setUploadFile(file);
      return false; // é˜»æ­¢è‡ªåŠ¨ä¸Šä¼ 
    },
    onRemove: () => {
      setUploadFile(null);
    }
  };
  
  /**
   * æ‰§è¡Œå¯¼å…¥
   */
  const handleImport = async () => {
    if (!selectedModule) {
      message.warning('è¯·é€‰æ‹©æ•°æ®æ¨¡å—');
      return;
    }
    
    if (!uploadFile) {
      message.warning('è¯·é€‰æ‹©è¦å¯¼å…¥çš„æ–‡ä»¶');
      return;
    }
    
    setImporting(true);
    
    try {
      const formData = new FormData();
      formData.append('file', uploadFile);
      formData.append('moduleType', selectedModule);
      formData.append('options', JSON.stringify({}));
      
      const response = await fetch('/api/admin/import/create', {
        method: 'POST',
        body: formData
      });
      
      const result = await response.json();
      
      if (result.success) {
        message.success('å¯¼å…¥ä»»åŠ¡å·²åˆ›å»ºï¼Œæ­£åœ¨å¤„ç†ä¸­...');
        setUploadFile(null);
        setSelectedModule('');
        loadImportTasks();
      } else {
        message.error(result.message || 'åˆ›å»ºå¯¼å…¥ä»»åŠ¡å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ›å»ºå¯¼å…¥ä»»åŠ¡å¤±è´¥:', error);
      message.error('åˆ›å»ºå¯¼å…¥ä»»åŠ¡å¤±è´¥');
    } finally {
      setImporting(false);
    }
  };
  
  /**
   * æŸ¥çœ‹ä»»åŠ¡è¯¦æƒ…
   */
  const handleViewTaskDetail = async (taskId) => {
    try {
      const response = await fetch(`/api/admin/import/task/${taskId}`);
      const result = await response.json();
      
      if (result.success) {
        setTaskDetailModal({ visible: true, task: result.data });
      } else {
        message.error('è·å–ä»»åŠ¡è¯¦æƒ…å¤±è´¥');
      }
    } catch (error) {
      console.error('è·å–ä»»åŠ¡è¯¦æƒ…å¤±è´¥:', error);
      message.error('è·å–ä»»åŠ¡è¯¦æƒ…å¤±è´¥');
    }
  };
  
  // ä»»åŠ¡çŠ¶æ€åˆ—é…ç½®
  const taskColumns = [
    {
      title: 'æ¨¡å—',
      dataIndex: 'module_name',
      key: 'module_name',
      render: (text, record) => (
        <span>
          {dataModules[record.module_type]?.icon} {text}
        </span>
      )
    },
    {
      title: 'æ–‡ä»¶å',
      dataIndex: 'file_name',
      key: 'file_name'
    },
    {
      title: 'çŠ¶æ€',
      dataIndex: 'status',
      key: 'status',
      render: (status) => {
        const statusMap = {
          pending: { color: '#faad14', text: 'ç­‰å¾…ä¸­', icon: 'â³' },
          processing: { color: '#1890ff', text: 'å¤„ç†ä¸­', icon: 'ğŸ”„' },
          validation_failed: { color: '#ff7a45', text: 'éªŒè¯å¤±è´¥', icon: 'âš ï¸' },
          completed: { color: '#52c41a', text: 'å·²å®Œæˆ', icon: 'âœ…' },
          failed: { color: '#ff4d4f', text: 'å¤±è´¥', icon: 'âŒ' }
        };
        
        const statusInfo = statusMap[status] || { color: '#d9d9d9', text: status, icon: 'â“' };
        
        return (
          <span style={{ color: statusInfo.color }}>
            {statusInfo.icon} {statusInfo.text}
          </span>
        );
      }
    },
    {
      title: 'è¿›åº¦',
      dataIndex: 'progress',
      key: 'progress',
      render: (progress, record) => (
        record.status === 'processing' ? (
          <Progress percent={progress} size="small" />
        ) : (
          record.status === 'completed' ? '100%' : '-'
        )
      )
    },
    {
      title: 'è®°å½•ç»Ÿè®¡',
      key: 'records',
      render: (_, record) => (
        record.total_records > 0 ? (
          <div>
            <div>æ€»æ•°: {record.total_records.toLocaleString()}</div>
            <div style={{ color: '#52c41a' }}>æˆåŠŸ: {record.success_records.toLocaleString()}</div>
            {record.failed_records > 0 && (
              <div style={{ color: '#ff4d4f' }}>å¤±è´¥: {record.failed_records.toLocaleString()}</div>
            )}
          </div>
        ) : '-'
      )
    },
    {
      title: 'åˆ›å»ºæ—¶é—´',
      dataIndex: 'created_at',
      key: 'created_at',
      render: (time) => new Date(time).toLocaleString()
    },
    {
      title: 'æ“ä½œ',
      key: 'action',
      render: (_, record) => (
        <Button
          type="link"
          onClick={() => handleViewTaskDetail(record.id)}
        >
          æŸ¥çœ‹è¯¦æƒ…
        </Button>
      )
    }
  ];
  
  return (
    <div className="data-import-page">
      <Card title="ğŸ“¥ æ•°æ®å¯¼å…¥" style={{ marginBottom: 24 }}>
        <Steps current={uploadFile ? (selectedModule ? 2 : 1) : 0} style={{ marginBottom: 24 }}>
          <Step title="é€‰æ‹©æ¨¡å—" description="é€‰æ‹©è¦å¯¼å…¥çš„æ•°æ®æ¨¡å—" />
          <Step title="ä¸Šä¼ æ–‡ä»¶" description="ä¸Šä¼ ç¬¦åˆæ ¼å¼çš„æ•°æ®æ–‡ä»¶" />
          <Step title="å¼€å§‹å¯¼å…¥" description="æ‰§è¡Œæ•°æ®å¯¼å…¥æ“ä½œ" />
        </Steps>
        
        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: 24 }}>
          <div>
            <h4>1. é€‰æ‹©æ•°æ®æ¨¡å—</h4>
            <Select
              placeholder="é€‰æ‹©è¦å¯¼å…¥çš„æ•°æ®æ¨¡å—"
              style={{ width: '100%', marginBottom: 16 }}
              value={selectedModule}
              onChange={setSelectedModule}
            >
              {Object.entries(dataModules).map(([key, module]) => (
                <Option key={key} value={key}>
                  {module.icon} {module.name}
                </Option>
              ))}
            </Select>
            
            {selectedModule && (
              <Alert
                message={dataModules[selectedModule].description}
                description={
                  <div>
                    <p>æœ€å¤§è®°å½•æ•°: {dataModules[selectedModule].maxRecords.toLocaleString()}</p>
                    <p>å¿…å¡«å­—æ®µ: {dataModules[selectedModule].requiredFields.join(', ')}</p>
                  </div>
                }
                type="info"
                showIcon
                style={{ marginBottom: 16 }}
              />
            )}
            
            <Button
              icon={<DownloadOutlined />}
              onClick={handleDownloadTemplate}
              disabled={!selectedModule}
              block
            >
              ä¸‹è½½å¯¼å…¥æ¨¡æ¿
            </Button>
          </div>
          
          <div>
            <h4>2. ä¸Šä¼ æ•°æ®æ–‡ä»¶</h4>
            <Dragger {...uploadProps} style={{ marginBottom: 16 }}>
              <p className="ant-upload-drag-icon">
                <InboxOutlined />
              </p>
              <p className="ant-upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤åŒºåŸŸä¸Šä¼ </p>
              <p className="ant-upload-hint">
                æ”¯æŒ Excel (.xlsx, .xls)ã€CSV (.csv)ã€JSON (.json) æ ¼å¼
                <br />
                æ–‡ä»¶å¤§å°ä¸è¶…è¿‡ 50MB
              </p>
            </Dragger>
            
            <Button
              type="primary"
              icon={<UploadOutlined />}
              onClick={handleImport}
              disabled={!selectedModule || !uploadFile}
              loading={importing}
              block
              size="large"
            >
              å¼€å§‹å¯¼å…¥
            </Button>
          </div>
        </div>
      </Card>
      
      <Card title="ğŸ“‹ å¯¼å…¥ä»»åŠ¡åˆ—è¡¨">
        <Table
          columns={taskColumns}
          dataSource={importTasks}
          rowKey="id"
          pagination={{
            pageSize: 10,
            showSizeChanger: true,
            showQuickJumper: true,
            showTotal: (total) => `å…± ${total} æ¡è®°å½•`
          }}
        />
      </Card>
      
      {/* ä»»åŠ¡è¯¦æƒ…å¼¹çª— */}
      <Modal
        title="å¯¼å…¥ä»»åŠ¡è¯¦æƒ…"
        visible={taskDetailModal.visible}
        onCancel={() => setTaskDetailModal({ visible: false, task: null })}
        footer={null}
        width={800}
      >
        {taskDetailModal.task && (
          <div>
            <Descriptions column={2} bordered>
              <Descriptions.Item label="ä»»åŠ¡ID">{taskDetailModal.task.id}</Descriptions.Item>
              <Descriptions.Item label="æ•°æ®æ¨¡å—">{taskDetailModal.task.module_name}</Descriptions.Item>
              <Descriptions.Item label="æ–‡ä»¶å">{taskDetailModal.task.file_name}</Descriptions.Item>
              <Descriptions.Item label="æ–‡ä»¶å¤§å°">
                {(taskDetailModal.task.file_size / 1024 / 1024).toFixed(2)} MB
              </Descriptions.Item>
              <Descriptions.Item label="çŠ¶æ€">{taskDetailModal.task.status}</Descriptions.Item>
              <Descriptions.Item label="è¿›åº¦">{taskDetailModal.task.progress}%</Descriptions.Item>
              <Descriptions.Item label="æ€»è®°å½•æ•°">{taskDetailModal.task.total_records}</Descriptions.Item>
              <Descriptions.Item label="æˆåŠŸè®°å½•æ•°">{taskDetailModal.task.success_records}</Descriptions.Item>
              <Descriptions.Item label="å¤±è´¥è®°å½•æ•°">{taskDetailModal.task.failed_records}</Descriptions.Item>
              <Descriptions.Item label="åˆ›å»ºæ—¶é—´">
                {new Date(taskDetailModal.task.created_at).toLocaleString()}
              </Descriptions.Item>
            </Descriptions>
            
            {taskDetailModal.task.validation_errors && taskDetailModal.task.validation_errors.length > 0 && (
              <div style={{ marginTop: 16 }}>
                <h4>éªŒè¯é”™è¯¯</h4>
                <div style={{ maxHeight: 300, overflow: 'auto' }}>
                  {taskDetailModal.task.validation_errors.map((error, index) => (
                    <Alert
                      key={index}
                      message={`ç¬¬ ${error.row} è¡Œ: ${error.error}`}
                      type="error"
                      showIcon
                      style={{ marginBottom: 8 }}
                    />
                  ))}
                </div>
              </div>
            )}
            
            {taskDetailModal.task.error && (
              <div style={{ marginTop: 16 }}>
                <Alert
                  message="æ‰§è¡Œé”™è¯¯"
                  description={taskDetailModal.task.error}
                  type="error"
                  showIcon
                />
              </div>
            )}
          </div>
        )}
      </Modal>
    </div>
  );
};

export default DataImportPage;
```

## å®‰å…¨å’Œæ€§èƒ½ä¼˜åŒ–

### 1. å®‰å…¨æªæ–½

#### å®‰å…¨é…ç½®
```javascript
/**
 * æ•°æ®å¯¼å…¥å¯¼å‡ºå®‰å…¨é…ç½®
 */
const SECURITY_CONFIG = {
  // æ–‡ä»¶ä¸Šä¼ å®‰å…¨
  upload: {
    maxFileSize: 50 * 1024 * 1024, // 50MB
    allowedMimeTypes: [
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'application/vnd.ms-excel',
      'text/csv',
      'application/json'
    ],
    scanForVirus: true,
    quarantinePath: './quarantine'
  },
  
  // æ•°æ®è„±æ•è§„åˆ™
  dataMasking: {
    phone: /(\d{3})\d{4}(\d{4})/,
    email: /(.{2}).*(@.*)/,
    idCard: /(\d{6})\d{8}(\d{4})/,
    address: /(.{6}).*(.{6})/
  },
  
  // è®¿é—®æ§åˆ¶
  accessControl: {
    maxConcurrentTasks: 3,
    dailyExportLimit: 10,
    dailyImportLimit: 5,
    ipWhitelist: process.env.ADMIN_IP_WHITELIST?.split(',') || []
  },
  
  // å®¡è®¡æ—¥å¿—
  auditLog: {
    enabled: true,
    logLevel: 'info',
    retentionDays: 90,
    sensitiveFields: ['password', 'private_key', 'mnemonic']
  }
};
```

### 2. æ€§èƒ½ä¼˜åŒ–

#### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
```javascript
/**
 * æ€§èƒ½ä¼˜åŒ–é…ç½®
 */
const PERFORMANCE_CONFIG = {
  // æ‰¹å¤„ç†é…ç½®
  batchProcessing: {
    batchSize: 1000,
    maxConcurrency: 5,
    memoryThreshold: 500 * 1024 * 1024 // 500MB
  },
  
  // ç¼“å­˜é…ç½®
  cache: {
    enabled: true,
    ttl: 3600, // 1å°æ—¶
    maxSize: 1000,
    keyPrefix: 'import_export:'
  },
  
  // é˜Ÿåˆ—é…ç½®
  queue: {
    concurrency: 3,
    maxRetries: 3,
    backoffDelay: 2000,
    removeOnComplete: 10,
    removeOnFail: 50
  }
};
```

## éƒ¨ç½²å’Œè¿ç»´

### 1. Dockeré…ç½®

#### Dockerfile
```dockerfile
# æ•°æ®å¯¼å…¥å¯¼å‡ºæœåŠ¡ Dockerfile
FROM node:16-alpine

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apk add --no-cache \
    python3 \
    make \
    g++ \
    cairo-dev \
    jpeg-dev \
    pango-dev \
    giflib-dev

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY package*.json ./
RUN npm ci --only=production

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# åˆ›å»ºå¿…è¦ç›®å½•
RUN mkdir -p uploads exports logs

# è®¾ç½®æƒé™
RUN chown -R node:node /app
USER node

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

EXPOSE 3000

CMD ["npm", "start"]
```

### 2. ç›‘æ§å’Œå‘Šè­¦

#### ç›‘æ§æŒ‡æ ‡
```javascript
/**
 * å¯¼å…¥å¯¼å‡ºç›‘æ§æŒ‡æ ‡
 */
const MONITORING_METRICS = {
  // ä»»åŠ¡æŒ‡æ ‡
  tasks: {
    totalTasks: 'import_export_tasks_total',
    activeTasks: 'import_export_tasks_active',
    completedTasks: 'import_export_tasks_completed',
    failedTasks: 'import_export_tasks_failed',
    averageProcessingTime: 'import_export_processing_time_avg'
  },
  
  // æ€§èƒ½æŒ‡æ ‡
  performance: {
    memoryUsage: 'import_export_memory_usage',
    cpuUsage: 'import_export_cpu_usage',
    diskUsage: 'import_export_disk_usage',
    queueLength: 'import_export_queue_length'
  },
  
  // ä¸šåŠ¡æŒ‡æ ‡
  business: {
    recordsProcessed: 'import_export_records_processed_total',
    filesProcessed: 'import_export_files_processed_total',
    errorRate: 'import_export_error_rate',
    throughput: 'import_export_throughput'
  }
};
```

## æ€»ç»“

æœ¬æ•°æ®å¯¼å…¥å¯¼å‡ºåŠŸèƒ½è®¾è®¡æ–‡æ¡£æä¾›äº†å®Œæ•´çš„è§£å†³æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š

### æ ¸å¿ƒç‰¹æ€§
- **å¤šæ ¼å¼æ”¯æŒ**: Excelã€CSVã€JSONã€PDF
- **8å¤§æ•°æ®æ¨¡å—**: ç”¨æˆ·ã€é’±åŒ…ã€äº¤æ˜“ã€ä»»åŠ¡ã€çº¢åŒ…ã€å›¢é˜Ÿã€æ’è¡Œæ¦œã€ç³»ç»Ÿæ—¥å¿—
- **å¼‚æ­¥å¤„ç†**: å¤§æ–‡ä»¶å¼‚æ­¥å¤„ç†ï¼Œå®æ—¶è¿›åº¦è·Ÿè¸ª
- **æ•°æ®éªŒè¯**: å®Œæ•´çš„æ•°æ®æ ¼å¼å’Œä¸šåŠ¡è§„åˆ™éªŒè¯
- **å®‰å…¨ä¿éšœ**: æ•°æ®è„±æ•ã€æƒé™æ§åˆ¶ã€å®¡è®¡æ—¥å¿—
- **æ€§èƒ½ä¼˜åŒ–**: æ‰¹å¤„ç†ã€ç¼“å­˜ã€é˜Ÿåˆ—ç®¡ç†

### æŠ€æœ¯äº®ç‚¹
- **æ¨¡å—åŒ–è®¾è®¡**: æ˜“äºæ‰©å±•å’Œç»´æŠ¤
- **é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
- **ç›‘æ§å‘Šè­¦**: å…¨é¢çš„æ€§èƒ½å’Œä¸šåŠ¡ç›‘æ§
- **ç”¨æˆ·ä½“éªŒ**: ç›´è§‚çš„ç•Œé¢å’Œæ“ä½œæµç¨‹

### å®‰å…¨åˆè§„
- **æ•°æ®ä¿æŠ¤**: æ•æ„Ÿæ•°æ®è‡ªåŠ¨è„±æ•
- **è®¿é—®æ§åˆ¶**: åŸºäºè§’è‰²çš„æƒé™ç®¡ç†
- **å®¡è®¡è¿½è¸ª**: å®Œæ•´çš„æ“ä½œæ—¥å¿—è®°å½•
- **æ–‡ä»¶å®‰å…¨**: æ–‡ä»¶ç±»å‹éªŒè¯å’Œç—…æ¯’æ‰«æ

è¯¥è®¾è®¡æ–¹æ¡ˆèƒ½å¤Ÿæ»¡è¶³æ•°å­—é’±åŒ…ç®¡ç†åå°çš„æ•°æ®å¯¼å…¥å¯¼å‡ºéœ€æ±‚ï¼Œæä¾›é«˜æ•ˆã€å®‰å…¨ã€æ˜“ç”¨çš„æ•°æ®å¤„ç†èƒ½åŠ›ã€‚