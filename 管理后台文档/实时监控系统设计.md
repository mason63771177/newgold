# ğŸ” å®æ—¶ç›‘æ§ç³»ç»Ÿè®¾è®¡æ–‡æ¡£

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è®¾è®¡äº†æ•°å­—é’±åŒ…ç®¡ç†åå°çš„å®æ—¶ç›‘æ§ç³»ç»Ÿï¼ŒåŒ…æ‹¬ç³»ç»Ÿæ€§èƒ½ç›‘æ§ã€ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§ã€å‘Šè­¦é€šçŸ¥æœºåˆ¶ã€æ—¥å¿—ç®¡ç†å’Œå¯è§†åŒ–å±•ç¤ºï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®šè¿è¡Œå’ŒåŠæ—¶å‘ç°é—®é¢˜ã€‚

## ç›‘æ§ç³»ç»Ÿæ¶æ„

### 1. æ•´ä½“æ¶æ„è®¾è®¡

```mermaid
graph TB
    A[æ•°æ®é‡‡é›†å±‚] --> B[æ•°æ®å¤„ç†å±‚]
    B --> C[å­˜å‚¨å±‚]
    C --> D[åˆ†æå±‚]
    D --> E[å±•ç¤ºå±‚]
    D --> F[å‘Šè­¦å±‚]
    
    A1[ç³»ç»ŸæŒ‡æ ‡é‡‡é›†] --> A
    A2[ä¸šåŠ¡æŒ‡æ ‡é‡‡é›†] --> A
    A3[æ—¥å¿—é‡‡é›†] --> A
    A4[ç”¨æˆ·è¡Œä¸ºé‡‡é›†] --> A
    
    B1[æ•°æ®æ¸…æ´—] --> B
    B2[æ•°æ®èšåˆ] --> B
    B3[å®æ—¶è®¡ç®—] --> B
    
    C1[æ—¶åºæ•°æ®åº“] --> C
    C2[å…³ç³»æ•°æ®åº“] --> C
    C3[æ—¥å¿—å­˜å‚¨] --> C
    
    E1[å®æ—¶ä»ªè¡¨æ¿] --> E
    E2[å†å²æŠ¥è¡¨] --> E
    E3[ç§»åŠ¨ç«¯å±•ç¤º] --> E
    
    F1[é‚®ä»¶å‘Šè­¦] --> F
    F2[çŸ­ä¿¡å‘Šè­¦] --> F
    F3[é’‰é’‰/ä¼å¾®å‘Šè­¦] --> F
```

### 2. æŠ€æœ¯æ ˆé€‰æ‹©

#### ç›‘æ§ç»„ä»¶
```javascript
/**
 * ç›‘æ§ç³»ç»ŸæŠ€æœ¯æ ˆé…ç½®
 */
const MONITORING_STACK = {
  // æ•°æ®é‡‡é›†
  dataCollection: {
    systemMetrics: 'node-exporter',      // ç³»ç»ŸæŒ‡æ ‡é‡‡é›†
    applicationMetrics: 'prom-client',   // åº”ç”¨æŒ‡æ ‡é‡‡é›†
    logCollection: 'winston',            // æ—¥å¿—é‡‡é›†
    tracing: 'jaeger',                   // é“¾è·¯è¿½è¸ª
  },
  
  // æ•°æ®å­˜å‚¨
  storage: {
    timeSeries: 'InfluxDB',              // æ—¶åºæ•°æ®åº“
    logs: 'Elasticsearch',               // æ—¥å¿—å­˜å‚¨
    cache: 'Redis',                      // ç¼“å­˜å­˜å‚¨
    relational: 'MySQL'                  // å…³ç³»æ•°æ®åº“
  },
  
  // æ•°æ®å¤„ç†
  processing: {
    realTime: 'Node.js Streams',         // å®æ—¶å¤„ç†
    batch: 'Node.js Cron Jobs',          // æ‰¹å¤„ç†
    aggregation: 'InfluxDB Functions'    // æ•°æ®èšåˆ
  },
  
  // å¯è§†åŒ–å±•ç¤º
  visualization: {
    dashboard: 'Grafana',                // ä»ªè¡¨æ¿
    webUI: 'React + Chart.js',          // Webç•Œé¢
    mobile: 'React Native'               // ç§»åŠ¨ç«¯
  },
  
  // å‘Šè­¦é€šçŸ¥
  alerting: {
    engine: 'Grafana Alerting',         // å‘Šè­¦å¼•æ“
    notification: 'Custom Webhook',      // é€šçŸ¥æœåŠ¡
    escalation: 'PagerDuty'             // å‘Šè­¦å‡çº§
  }
};
```

## æ•°æ®é‡‡é›†ç³»ç»Ÿ

### 1. ç³»ç»ŸæŒ‡æ ‡é‡‡é›†

#### æœåŠ¡å™¨æ€§èƒ½ç›‘æ§
```javascript
/**
 * ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡é‡‡é›†å™¨
 */
const os = require('os');
const fs = require('fs').promises;
const { InfluxDB, Point } = require('@influxdata/influxdb-client');

class SystemMetricsCollector {
  constructor() {
    this.influxDB = new InfluxDB({
      url: process.env.INFLUXDB_URL,
      token: process.env.INFLUXDB_TOKEN
    });
    this.writeApi = this.influxDB.getWriteApi(
      process.env.INFLUXDB_ORG,
      process.env.INFLUXDB_BUCKET
    );
  }
  
  /**
   * æ”¶é›†CPUæŒ‡æ ‡
   */
  async collectCPUMetrics() {
    const cpus = os.cpus();
    const loadAvg = os.loadavg();
    
    // CPUä½¿ç”¨ç‡
    let totalIdle = 0;
    let totalTick = 0;
    
    cpus.forEach(cpu => {
      for (const type in cpu.times) {
        totalTick += cpu.times[type];
      }
      totalIdle += cpu.times.idle;
    });
    
    const cpuUsage = 100 - (totalIdle / totalTick * 100);
    
    // å†™å…¥InfluxDB
    const point = new Point('system_cpu')
      .floatField('usage_percent', cpuUsage)
      .floatField('load_1m', loadAvg[0])
      .floatField('load_5m', loadAvg[1])
      .floatField('load_15m', loadAvg[2])
      .intField('core_count', cpus.length)
      .tag('host', os.hostname())
      .timestamp(new Date());
    
    this.writeApi.writePoint(point);
    
    return {
      usage: cpuUsage,
      loadAverage: loadAvg,
      coreCount: cpus.length
    };
  }
  
  /**
   * æ”¶é›†å†…å­˜æŒ‡æ ‡
   */
  async collectMemoryMetrics() {
    const totalMem = os.totalmem();
    const freeMem = os.freemem();
    const usedMem = totalMem - freeMem;
    const memUsage = (usedMem / totalMem) * 100;
    
    // è·å–è¿›ç¨‹å†…å­˜ä½¿ç”¨æƒ…å†µ
    const processMemory = process.memoryUsage();
    
    const point = new Point('system_memory')
      .intField('total_bytes', totalMem)
      .intField('used_bytes', usedMem)
      .intField('free_bytes', freeMem)
      .floatField('usage_percent', memUsage)
      .intField('process_rss', processMemory.rss)
      .intField('process_heap_used', processMemory.heapUsed)
      .intField('process_heap_total', processMemory.heapTotal)
      .tag('host', os.hostname())
      .timestamp(new Date());
    
    this.writeApi.writePoint(point);
    
    return {
      total: totalMem,
      used: usedMem,
      free: freeMem,
      usage: memUsage,
      process: processMemory
    };
  }
  
  /**
   * æ”¶é›†ç£ç›˜æŒ‡æ ‡
   */
  async collectDiskMetrics() {
    try {
      const stats = await fs.stat('/');
      // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦ä½¿ç”¨ç³»ç»Ÿå‘½ä»¤è·å–æ›´å‡†ç¡®çš„ç£ç›˜ä½¿ç”¨æƒ…å†µ
      const { exec } = require('child_process');
      const { promisify } = require('util');
      const execAsync = promisify(exec);
      
      const { stdout } = await execAsync('df -h / | tail -1');
      const diskInfo = stdout.trim().split(/\s+/);
      
      const point = new Point('system_disk')
        .stringField('filesystem', diskInfo[0])
        .stringField('size', diskInfo[1])
        .stringField('used', diskInfo[2])
        .stringField('available', diskInfo[3])
        .stringField('usage_percent', diskInfo[4])
        .tag('host', os.hostname())
        .timestamp(new Date());
      
      this.writeApi.writePoint(point);
      
      return {
        filesystem: diskInfo[0],
        size: diskInfo[1],
        used: diskInfo[2],
        available: diskInfo[3],
        usage: diskInfo[4]
      };
    } catch (error) {
      console.error('ç£ç›˜æŒ‡æ ‡æ”¶é›†å¤±è´¥:', error);
      return null;
    }
  }
  
  /**
   * æ”¶é›†ç½‘ç»œæŒ‡æ ‡
   */
  async collectNetworkMetrics() {
    const networkInterfaces = os.networkInterfaces();
    const metrics = [];
    
    for (const [name, interfaces] of Object.entries(networkInterfaces)) {
      for (const iface of interfaces) {
        if (!iface.internal && iface.family === 'IPv4') {
          const point = new Point('system_network')
            .stringField('interface', name)
            .stringField('address', iface.address)
            .stringField('netmask', iface.netmask)
            .stringField('mac', iface.mac)
            .tag('host', os.hostname())
            .timestamp(new Date());
          
          this.writeApi.writePoint(point);
          
          metrics.push({
            interface: name,
            address: iface.address,
            netmask: iface.netmask,
            mac: iface.mac
          });
        }
      }
    }
    
    return metrics;
  }
  
  /**
   * å¯åŠ¨å®šæ—¶é‡‡é›†
   */
  startCollection() {
    // æ¯30ç§’é‡‡é›†ä¸€æ¬¡ç³»ç»ŸæŒ‡æ ‡
    setInterval(async () => {
      try {
        await Promise.all([
          this.collectCPUMetrics(),
          this.collectMemoryMetrics(),
          this.collectDiskMetrics(),
          this.collectNetworkMetrics()
        ]);
        
        // åˆ·æ–°å†™å…¥ç¼“å†²åŒº
        await this.writeApi.flush();
      } catch (error) {
        console.error('ç³»ç»ŸæŒ‡æ ‡é‡‡é›†å¤±è´¥:', error);
      }
    }, 30000);
    
    console.log('ç³»ç»ŸæŒ‡æ ‡é‡‡é›†å™¨å·²å¯åŠ¨');
  }
}
```

### 2. åº”ç”¨æŒ‡æ ‡é‡‡é›†

#### ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§
```javascript
/**
 * ä¸šåŠ¡æŒ‡æ ‡é‡‡é›†å™¨
 */
class BusinessMetricsCollector {
  constructor(db, influxDB) {
    this.db = db;
    this.influxDB = influxDB;
    this.writeApi = influxDB.getWriteApi(
      process.env.INFLUXDB_ORG,
      process.env.INFLUXDB_BUCKET
    );
  }
  
  /**
   * æ”¶é›†ç”¨æˆ·æŒ‡æ ‡
   */
  async collectUserMetrics() {
    try {
      // æ€»ç”¨æˆ·æ•°
      const [totalUsers] = await this.db.query(
        'SELECT COUNT(*) as count FROM users WHERE deleted_at IS NULL'
      );
      
      // æ´»è·ƒç”¨æˆ·æ•°ï¼ˆæœ€è¿‘24å°æ—¶ç™»å½•ï¼‰
      const [activeUsers] = await this.db.query(`
        SELECT COUNT(*) as count FROM users 
        WHERE last_login_at > DATE_SUB(NOW(), INTERVAL 24 HOUR)
          AND deleted_at IS NULL
      `);
      
      // æ–°æ³¨å†Œç”¨æˆ·æ•°ï¼ˆä»Šæ—¥ï¼‰
      const [newUsers] = await this.db.query(`
        SELECT COUNT(*) as count FROM users 
        WHERE DATE(created_at) = CURDATE()
          AND deleted_at IS NULL
      `);
      
      // ç”¨æˆ·çŠ¶æ€åˆ†å¸ƒ
      const userStatusStats = await this.db.query(`
        SELECT status, COUNT(*) as count 
        FROM users 
        WHERE deleted_at IS NULL
        GROUP BY status
      `);
      
      // å†™å…¥æŒ‡æ ‡
      const point = new Point('business_users')
        .intField('total_users', totalUsers.count)
        .intField('active_users_24h', activeUsers.count)
        .intField('new_users_today', newUsers.count)
        .timestamp(new Date());
      
      // æ·»åŠ çŠ¶æ€åˆ†å¸ƒ
      userStatusStats.forEach(stat => {
        point.intField(`users_${stat.status}`, stat.count);
      });
      
      this.writeApi.writePoint(point);
      
      return {
        totalUsers: totalUsers.count,
        activeUsers: activeUsers.count,
        newUsers: newUsers.count,
        statusDistribution: userStatusStats
      };
    } catch (error) {
      console.error('ç”¨æˆ·æŒ‡æ ‡æ”¶é›†å¤±è´¥:', error);
      return null;
    }
  }
  
  /**
   * æ”¶é›†äº¤æ˜“æŒ‡æ ‡
   */
  async collectTransactionMetrics() {
    try {
      // ä»Šæ—¥äº¤æ˜“ç»Ÿè®¡
      const [todayStats] = await this.db.query(`
        SELECT 
          COUNT(*) as total_count,
          SUM(CASE WHEN type = 'deposit' THEN 1 ELSE 0 END) as deposit_count,
          SUM(CASE WHEN type = 'withdraw' THEN 1 ELSE 0 END) as withdraw_count,
          SUM(CASE WHEN status = 'confirmed' THEN amount ELSE 0 END) as confirmed_amount,
          SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) as pending_amount
        FROM transactions 
        WHERE DATE(created_at) = CURDATE()
      `);
      
      // äº¤æ˜“çŠ¶æ€åˆ†å¸ƒ
      const statusStats = await this.db.query(`
        SELECT status, COUNT(*) as count, SUM(amount) as total_amount
        FROM transactions 
        WHERE DATE(created_at) = CURDATE()
        GROUP BY status
      `);
      
      // æœ€è¿‘1å°æ—¶äº¤æ˜“é‡
      const [hourlyStats] = await this.db.query(`
        SELECT 
          COUNT(*) as count,
          SUM(amount) as amount
        FROM transactions 
        WHERE created_at > DATE_SUB(NOW(), INTERVAL 1 HOUR)
          AND status = 'confirmed'
      `);
      
      const point = new Point('business_transactions')
        .intField('today_total', todayStats.total_count)
        .intField('today_deposits', todayStats.deposit_count)
        .intField('today_withdraws', todayStats.withdraw_count)
        .floatField('today_confirmed_amount', parseFloat(todayStats.confirmed_amount || 0))
        .floatField('today_pending_amount', parseFloat(todayStats.pending_amount || 0))
        .intField('hourly_count', hourlyStats.count)
        .floatField('hourly_amount', parseFloat(hourlyStats.amount || 0))
        .timestamp(new Date());
      
      // æ·»åŠ çŠ¶æ€åˆ†å¸ƒ
      statusStats.forEach(stat => {
        point.intField(`${stat.status}_count`, stat.count);
        point.floatField(`${stat.status}_amount`, parseFloat(stat.total_amount || 0));
      });
      
      this.writeApi.writePoint(point);
      
      return {
        today: todayStats,
        hourly: hourlyStats,
        statusDistribution: statusStats
      };
    } catch (error) {
      console.error('äº¤æ˜“æŒ‡æ ‡æ”¶é›†å¤±è´¥:', error);
      return null;
    }
  }
  
  /**
   * æ”¶é›†é’±åŒ…æŒ‡æ ‡
   */
  async collectWalletMetrics() {
    try {
      // é’±åŒ…æ€»æ•°å’Œä½™é¢ç»Ÿè®¡
      const [walletStats] = await this.db.query(`
        SELECT 
          COUNT(*) as total_wallets,
          COUNT(CASE WHEN status = 'active' THEN 1 END) as active_wallets,
          SUM(balance) as total_balance,
          SUM(frozen_balance) as total_frozen_balance,
          AVG(balance) as avg_balance
        FROM wallets
      `);
      
      // å¤§é¢é’±åŒ…ç»Ÿè®¡ï¼ˆä½™é¢>1000 USDTï¼‰
      const [largeWallets] = await this.db.query(`
        SELECT COUNT(*) as count, SUM(balance) as total_balance
        FROM wallets 
        WHERE balance > 1000 AND status = 'active'
      `);
      
      // é›¶ä½™é¢é’±åŒ…æ•°é‡
      const [zeroBalanceWallets] = await this.db.query(`
        SELECT COUNT(*) as count
        FROM wallets 
        WHERE balance = 0 AND status = 'active'
      `);
      
      const point = new Point('business_wallets')
        .intField('total_wallets', walletStats.total_wallets)
        .intField('active_wallets', walletStats.active_wallets)
        .floatField('total_balance', parseFloat(walletStats.total_balance || 0))
        .floatField('total_frozen_balance', parseFloat(walletStats.total_frozen_balance || 0))
        .floatField('avg_balance', parseFloat(walletStats.avg_balance || 0))
        .intField('large_wallets_count', largeWallets.count)
        .floatField('large_wallets_balance', parseFloat(largeWallets.total_balance || 0))
        .intField('zero_balance_wallets', zeroBalanceWallets.count)
        .timestamp(new Date());
      
      this.writeApi.writePoint(point);
      
      return {
        total: walletStats,
        largeWallets: largeWallets,
        zeroBalance: zeroBalanceWallets.count
      };
    } catch (error) {
      console.error('é’±åŒ…æŒ‡æ ‡æ”¶é›†å¤±è´¥:', error);
      return null;
    }
  }
  
  /**
   * å¯åŠ¨ä¸šåŠ¡æŒ‡æ ‡é‡‡é›†
   */
  startCollection() {
    // æ¯åˆ†é’Ÿé‡‡é›†ä¸€æ¬¡ä¸šåŠ¡æŒ‡æ ‡
    setInterval(async () => {
      try {
        await Promise.all([
          this.collectUserMetrics(),
          this.collectTransactionMetrics(),
          this.collectWalletMetrics()
        ]);
        
        await this.writeApi.flush();
      } catch (error) {
        console.error('ä¸šåŠ¡æŒ‡æ ‡é‡‡é›†å¤±è´¥:', error);
      }
    }, 60000);
    
    console.log('ä¸šåŠ¡æŒ‡æ ‡é‡‡é›†å™¨å·²å¯åŠ¨');
  }
}
```

### 3. APIæ€§èƒ½ç›‘æ§

#### æ¥å£æ€§èƒ½è¿½è¸ª
```javascript
/**
 * APIæ€§èƒ½ç›‘æ§ä¸­é—´ä»¶
 */
class APIPerformanceMonitor {
  constructor(influxDB) {
    this.influxDB = influxDB;
    this.writeApi = influxDB.getWriteApi(
      process.env.INFLUXDB_ORG,
      process.env.INFLUXDB_BUCKET
    );
  }
  
  /**
   * Expressä¸­é—´ä»¶
   */
  middleware() {
    return (req, res, next) => {
      const startTime = Date.now();
      const startHrTime = process.hrtime();
      
      // ç›‘å¬å“åº”ç»“æŸäº‹ä»¶
      res.on('finish', () => {
        const duration = Date.now() - startTime;
        const hrDuration = process.hrtime(startHrTime);
        const durationMs = hrDuration[0] * 1000 + hrDuration[1] / 1000000;
        
        // è®°å½•APIæ€§èƒ½æŒ‡æ ‡
        this.recordAPIMetrics({
          method: req.method,
          path: req.route ? req.route.path : req.path,
          statusCode: res.statusCode,
          duration: durationMs,
          userAgent: req.get('User-Agent'),
          ip: req.ip,
          userId: req.user ? req.user.id : null
        });
      });
      
      next();
    };
  }
  
  /**
   * è®°å½•APIæŒ‡æ ‡
   */
  recordAPIMetrics(metrics) {
    const point = new Point('api_performance')
      .stringField('method', metrics.method)
      .stringField('path', metrics.path)
      .intField('status_code', metrics.statusCode)
      .floatField('duration_ms', metrics.duration)
      .stringField('user_agent', metrics.userAgent || '')
      .stringField('ip', metrics.ip)
      .tag('endpoint', `${metrics.method} ${metrics.path}`)
      .tag('status_class', `${Math.floor(metrics.statusCode / 100)}xx`)
      .timestamp(new Date());
    
    if (metrics.userId) {
      point.intField('user_id', metrics.userId);
    }
    
    this.writeApi.writePoint(point);
    
    // å¼‚æ­¥åˆ·æ–°ï¼Œé¿å…å½±å“å“åº”æ€§èƒ½
    setImmediate(() => {
      this.writeApi.flush().catch(error => {
        console.error('APIæŒ‡æ ‡å†™å…¥å¤±è´¥:', error);
      });
    });
  }
  
  /**
   * è·å–APIæ€§èƒ½ç»Ÿè®¡
   */
  async getAPIStats(timeRange = '1h') {
    const queryApi = this.influxDB.getQueryApi(process.env.INFLUXDB_ORG);
    
    const query = `
      from(bucket: "${process.env.INFLUXDB_BUCKET}")
        |> range(start: -${timeRange})
        |> filter(fn: (r) => r._measurement == "api_performance")
        |> group(columns: ["endpoint"])
        |> aggregateWindow(every: 5m, fn: mean, createEmpty: false)
        |> yield(name: "mean")
    `;
    
    const results = [];
    
    return new Promise((resolve, reject) => {
      queryApi.queryRows(query, {
        next(row, tableMeta) {
          const o = tableMeta.toObject(row);
          results.push(o);
        },
        error(error) {
          reject(error);
        },
        complete() {
          resolve(results);
        }
      });
    });
  }
}
```

## å‘Šè­¦ç³»ç»Ÿ

### 1. å‘Šè­¦è§„åˆ™å¼•æ“

#### å‘Šè­¦è§„åˆ™é…ç½®
```javascript
/**
 * å‘Šè­¦è§„åˆ™ç®¡ç†å™¨
 */
class AlertRuleManager {
  constructor(db, notificationService) {
    this.db = db;
    this.notificationService = notificationService;
    this.rules = new Map();
    this.loadRules();
  }
  
  /**
   * åŠ è½½å‘Šè­¦è§„åˆ™
   */
  async loadRules() {
    const alertRules = [
      // ç³»ç»Ÿæ€§èƒ½å‘Šè­¦
      {
        id: 'cpu_high',
        name: 'CPUä½¿ç”¨ç‡è¿‡é«˜',
        type: 'system',
        condition: 'cpu_usage > 80',
        severity: 'warning',
        duration: '5m',
        description: 'CPUä½¿ç”¨ç‡è¶…è¿‡80%æŒç»­5åˆ†é’Ÿ',
        enabled: true
      },
      {
        id: 'memory_high',
        name: 'å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜',
        type: 'system',
        condition: 'memory_usage > 85',
        severity: 'critical',
        duration: '3m',
        description: 'å†…å­˜ä½¿ç”¨ç‡è¶…è¿‡85%æŒç»­3åˆ†é’Ÿ',
        enabled: true
      },
      {
        id: 'disk_full',
        name: 'ç£ç›˜ç©ºé—´ä¸è¶³',
        type: 'system',
        condition: 'disk_usage > 90',
        severity: 'critical',
        duration: '1m',
        description: 'ç£ç›˜ä½¿ç”¨ç‡è¶…è¿‡90%',
        enabled: true
      },
      
      // ä¸šåŠ¡å‘Šè­¦
      {
        id: 'transaction_failure_rate',
        name: 'äº¤æ˜“å¤±è´¥ç‡è¿‡é«˜',
        type: 'business',
        condition: 'transaction_failure_rate > 10',
        severity: 'warning',
        duration: '10m',
        description: 'äº¤æ˜“å¤±è´¥ç‡è¶…è¿‡10%æŒç»­10åˆ†é’Ÿ',
        enabled: true
      },
      {
        id: 'large_transaction',
        name: 'å¤§é¢äº¤æ˜“å‘Šè­¦',
        type: 'business',
        condition: 'transaction_amount > 10000',
        severity: 'info',
        duration: '0m',
        description: 'å•ç¬”äº¤æ˜“é‡‘é¢è¶…è¿‡10000 USDT',
        enabled: true
      },
      {
        id: 'api_response_slow',
        name: 'APIå“åº”ç¼“æ…¢',
        type: 'performance',
        condition: 'api_response_time > 2000',
        severity: 'warning',
        duration: '5m',
        description: 'APIå¹³å‡å“åº”æ—¶é—´è¶…è¿‡2ç§’æŒç»­5åˆ†é’Ÿ',
        enabled: true
      },
      
      // å®‰å…¨å‘Šè­¦
      {
        id: 'failed_login_attempts',
        name: 'ç™»å½•å¤±è´¥æ¬¡æ•°è¿‡å¤š',
        type: 'security',
        condition: 'failed_login_count > 10',
        severity: 'warning',
        duration: '5m',
        description: '5åˆ†é’Ÿå†…ç™»å½•å¤±è´¥æ¬¡æ•°è¶…è¿‡10æ¬¡',
        enabled: true
      },
      {
        id: 'suspicious_ip',
        name: 'å¯ç–‘IPè®¿é—®',
        type: 'security',
        condition: 'requests_from_ip > 1000',
        severity: 'critical',
        duration: '1m',
        description: 'å•ä¸ªIP 1åˆ†é’Ÿå†…è¯·æ±‚æ¬¡æ•°è¶…è¿‡1000æ¬¡',
        enabled: true
      }
    ];
    
    alertRules.forEach(rule => {
      this.rules.set(rule.id, rule);
    });
    
    console.log(`å·²åŠ è½½ ${alertRules.length} æ¡å‘Šè­¦è§„åˆ™`);
  }
  
  /**
   * æ£€æŸ¥å‘Šè­¦æ¡ä»¶
   */
  async checkAlerts() {
    for (const [ruleId, rule] of this.rules) {
      if (!rule.enabled) continue;
      
      try {
        const isTriggered = await this.evaluateRule(rule);
        
        if (isTriggered) {
          await this.triggerAlert(rule);
        }
      } catch (error) {
        console.error(`å‘Šè­¦è§„åˆ™ ${ruleId} æ£€æŸ¥å¤±è´¥:`, error);
      }
    }
  }
  
  /**
   * è¯„ä¼°å‘Šè­¦è§„åˆ™
   */
  async evaluateRule(rule) {
    switch (rule.type) {
      case 'system':
        return await this.evaluateSystemRule(rule);
      case 'business':
        return await this.evaluateBusinessRule(rule);
      case 'performance':
        return await this.evaluatePerformanceRule(rule);
      case 'security':
        return await this.evaluateSecurityRule(rule);
      default:
        return false;
    }
  }
  
  /**
   * è¯„ä¼°ç³»ç»Ÿå‘Šè­¦è§„åˆ™
   */
  async evaluateSystemRule(rule) {
    const queryApi = this.influxDB.getQueryApi(process.env.INFLUXDB_ORG);
    
    let query;
    switch (rule.id) {
      case 'cpu_high':
        query = `
          from(bucket: "${process.env.INFLUXDB_BUCKET}")
            |> range(start: -${rule.duration})
            |> filter(fn: (r) => r._measurement == "system_cpu" and r._field == "usage_percent")
            |> mean()
        `;
        break;
      case 'memory_high':
        query = `
          from(bucket: "${process.env.INFLUXDB_BUCKET}")
            |> range(start: -${rule.duration})
            |> filter(fn: (r) => r._measurement == "system_memory" and r._field == "usage_percent")
            |> mean()
        `;
        break;
      default:
        return false;
    }
    
    const result = await this.executeInfluxQuery(query);
    const threshold = this.extractThreshold(rule.condition);
    
    return result && result._value > threshold;
  }
  
  /**
   * è¯„ä¼°ä¸šåŠ¡å‘Šè­¦è§„åˆ™
   */
  async evaluateBusinessRule(rule) {
    switch (rule.id) {
      case 'transaction_failure_rate':
        const [stats] = await this.db.query(`
          SELECT 
            COUNT(*) as total,
            SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed
          FROM transactions 
          WHERE created_at > DATE_SUB(NOW(), INTERVAL 10 MINUTE)
        `);
        
        const failureRate = stats.total > 0 ? (stats.failed / stats.total * 100) : 0;
        return failureRate > 10;
        
      case 'large_transaction':
        const [largeTransactions] = await this.db.query(`
          SELECT COUNT(*) as count
          FROM transactions 
          WHERE amount > 10000 
            AND created_at > DATE_SUB(NOW(), INTERVAL 1 MINUTE)
            AND status = 'confirmed'
        `);
        
        return largeTransactions.count > 0;
        
      default:
        return false;
    }
  }
  
  /**
   * è§¦å‘å‘Šè­¦
   */
  async triggerAlert(rule) {
    const alert = {
      id: `${rule.id}_${Date.now()}`,
      ruleId: rule.id,
      ruleName: rule.name,
      severity: rule.severity,
      description: rule.description,
      timestamp: new Date(),
      status: 'firing'
    };
    
    // ä¿å­˜å‘Šè­¦è®°å½•
    await this.saveAlert(alert);
    
    // å‘é€é€šçŸ¥
    await this.notificationService.sendAlert(alert);
    
    console.log(`å‘Šè­¦è§¦å‘: ${rule.name} - ${rule.description}`);
  }
  
  /**
   * ä¿å­˜å‘Šè­¦è®°å½•
   */
  async saveAlert(alert) {
    await this.db.query(`
      INSERT INTO alert_records (
        alert_id, rule_id, rule_name, severity, description, 
        status, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `, [
      alert.id, alert.ruleId, alert.ruleName, alert.severity,
      alert.description, alert.status, alert.timestamp
    ]);
  }
  
  /**
   * å¯åŠ¨å‘Šè­¦æ£€æŸ¥
   */
  startMonitoring() {
    // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡å‘Šè­¦
    setInterval(() => {
      this.checkAlerts().catch(error => {
        console.error('å‘Šè­¦æ£€æŸ¥å¤±è´¥:', error);
      });
    }, 60000);
    
    console.log('å‘Šè­¦ç›‘æ§å·²å¯åŠ¨');
  }
}
```

### 2. é€šçŸ¥æœåŠ¡

#### å¤šæ¸ é“é€šçŸ¥å®ç°
```javascript
/**
 * é€šçŸ¥æœåŠ¡ç®¡ç†å™¨
 */
class NotificationService {
  constructor() {
    this.channels = {
      email: new EmailNotifier(),
      sms: new SMSNotifier(),
      webhook: new WebhookNotifier(),
      dingtalk: new DingTalkNotifier()
    };
    
    this.notificationRules = this.loadNotificationRules();
  }
  
  /**
   * åŠ è½½é€šçŸ¥è§„åˆ™
   */
  loadNotificationRules() {
    return {
      critical: ['email', 'sms', 'dingtalk'],
      warning: ['email', 'dingtalk'],
      info: ['dingtalk']
    };
  }
  
  /**
   * å‘é€å‘Šè­¦é€šçŸ¥
   */
  async sendAlert(alert) {
    const channels = this.notificationRules[alert.severity] || ['email'];
    
    const notifications = channels.map(channel => {
      if (this.channels[channel]) {
        return this.channels[channel].send(alert);
      }
    });
    
    try {
      await Promise.all(notifications);
      console.log(`å‘Šè­¦é€šçŸ¥å·²å‘é€: ${alert.ruleName}`);
    } catch (error) {
      console.error('å‘Šè­¦é€šçŸ¥å‘é€å¤±è´¥:', error);
    }
  }
}

/**
 * é‚®ä»¶é€šçŸ¥å™¨
 */
class EmailNotifier {
  constructor() {
    this.transporter = require('nodemailer').createTransporter({
      host: process.env.SMTP_HOST,
      port: process.env.SMTP_PORT,
      secure: true,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS
      }
    });
  }
  
  async send(alert) {
    const mailOptions = {
      from: process.env.SMTP_FROM,
      to: process.env.ALERT_EMAIL_RECIPIENTS,
      subject: `[${alert.severity.toUpperCase()}] ${alert.ruleName}`,
      html: this.generateEmailTemplate(alert)
    };
    
    await this.transporter.sendMail(mailOptions);
  }
  
  generateEmailTemplate(alert) {
    const severityColors = {
      critical: '#ff4444',
      warning: '#ffaa00',
      info: '#00aaff'
    };
    
    return `
      <div style="font-family: Arial, sans-serif; max-width: 600px;">
        <div style="background: ${severityColors[alert.severity]}; color: white; padding: 20px;">
          <h2>ğŸš¨ ç³»ç»Ÿå‘Šè­¦é€šçŸ¥</h2>
        </div>
        <div style="padding: 20px; border: 1px solid #ddd;">
          <h3>${alert.ruleName}</h3>
          <p><strong>ä¸¥é‡ç¨‹åº¦:</strong> ${alert.severity}</p>
          <p><strong>æè¿°:</strong> ${alert.description}</p>
          <p><strong>æ—¶é—´:</strong> ${alert.timestamp.toLocaleString()}</p>
          <p><strong>å‘Šè­¦ID:</strong> ${alert.id}</p>
        </div>
        <div style="padding: 20px; background: #f5f5f5; font-size: 12px; color: #666;">
          <p>æ­¤é‚®ä»¶ç”±æ•°å­—é’±åŒ…ç›‘æ§ç³»ç»Ÿè‡ªåŠ¨å‘é€ï¼Œè¯·å‹¿å›å¤ã€‚</p>
        </div>
      </div>
    `;
  }
}

/**
 * é’‰é’‰é€šçŸ¥å™¨
 */
class DingTalkNotifier {
  constructor() {
    this.webhook = process.env.DINGTALK_WEBHOOK;
    this.secret = process.env.DINGTALK_SECRET;
  }
  
  async send(alert) {
    if (!this.webhook) return;
    
    const timestamp = Date.now();
    const sign = this.generateSign(timestamp);
    
    const message = {
      msgtype: 'markdown',
      markdown: {
        title: `ç³»ç»Ÿå‘Šè­¦: ${alert.ruleName}`,
        text: this.generateMarkdownMessage(alert)
      }
    };
    
    const url = `${this.webhook}&timestamp=${timestamp}&sign=${sign}`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(message)
    });
    
    if (!response.ok) {
      throw new Error(`é’‰é’‰é€šçŸ¥å‘é€å¤±è´¥: ${response.statusText}`);
    }
  }
  
  generateMarkdownMessage(alert) {
    const severityEmojis = {
      critical: 'ğŸ”´',
      warning: 'ğŸŸ¡',
      info: 'ğŸ”µ'
    };
    
    return `
### ${severityEmojis[alert.severity]} ${alert.ruleName}

**ä¸¥é‡ç¨‹åº¦:** ${alert.severity}

**æè¿°:** ${alert.description}

**æ—¶é—´:** ${alert.timestamp.toLocaleString()}

**å‘Šè­¦ID:** ${alert.id}

---
*æ•°å­—é’±åŒ…ç›‘æ§ç³»ç»Ÿ*
    `;
  }
  
  generateSign(timestamp) {
    const crypto = require('crypto');
    const stringToSign = `${timestamp}\n${this.secret}`;
    return crypto.createHmac('sha256', this.secret)
      .update(stringToSign)
      .digest('base64');
  }
}
```

## æ—¥å¿—ç®¡ç†ç³»ç»Ÿ

### 1. ç»“æ„åŒ–æ—¥å¿—

#### æ—¥å¿—è®°å½•å™¨
```javascript
/**
 * ç»“æ„åŒ–æ—¥å¿—ç®¡ç†å™¨
 */
const winston = require('winston');
const { ElasticsearchTransport } = require('winston-elasticsearch');

class LogManager {
  constructor() {
    this.logger = this.createLogger();
  }
  
  /**
   * åˆ›å»ºæ—¥å¿—è®°å½•å™¨
   */
  createLogger() {
    const transports = [
      // æ§åˆ¶å°è¾“å‡º
      new winston.transports.Console({
        format: winston.format.combine(
          winston.format.colorize(),
          winston.format.timestamp(),
          winston.format.printf(({ timestamp, level, message, ...meta }) => {
            return `${timestamp} [${level}]: ${message} ${
              Object.keys(meta).length ? JSON.stringify(meta, null, 2) : ''
            }`;
          })
        )
      }),
      
      // æ–‡ä»¶è¾“å‡º
      new winston.transports.File({
        filename: 'logs/error.log',
        level: 'error',
        format: winston.format.combine(
          winston.format.timestamp(),
          winston.format.json()
        )
      }),
      
      new winston.transports.File({
        filename: 'logs/combined.log',
        format: winston.format.combine(
          winston.format.timestamp(),
          winston.format.json()
        )
      })
    ];
    
    // ç”Ÿäº§ç¯å¢ƒæ·»åŠ Elasticsearchä¼ è¾“
    if (process.env.NODE_ENV === 'production' && process.env.ELASTICSEARCH_URL) {
      transports.push(
        new ElasticsearchTransport({
          level: 'info',
          clientOpts: {
            node: process.env.ELASTICSEARCH_URL,
            auth: {
              username: process.env.ELASTICSEARCH_USER,
              password: process.env.ELASTICSEARCH_PASS
            }
          },
          index: 'wallet-logs',
          transformer: (logData) => {
            return {
              '@timestamp': new Date().toISOString(),
              level: logData.level,
              message: logData.message,
              meta: logData.meta,
              service: 'wallet-backend',
              environment: process.env.NODE_ENV
            };
          }
        })
      );
    }
    
    return winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      defaultMeta: {
        service: 'wallet-backend',
        version: process.env.APP_VERSION || '1.0.0'
      },
      transports
    });
  }
  
  /**
   * è®°å½•ç”¨æˆ·æ“ä½œæ—¥å¿—
   */
  logUserAction(userId, action, details = {}) {
    this.logger.info('ç”¨æˆ·æ“ä½œ', {
      type: 'user_action',
      userId,
      action,
      details,
      timestamp: new Date().toISOString()
    });
  }
  
  /**
   * è®°å½•äº¤æ˜“æ—¥å¿—
   */
  logTransaction(transactionId, type, amount, status, details = {}) {
    this.logger.info('äº¤æ˜“è®°å½•', {
      type: 'transaction',
      transactionId,
      transactionType: type,
      amount,
      status,
      details,
      timestamp: new Date().toISOString()
    });
  }
  
  /**
   * è®°å½•å®‰å…¨äº‹ä»¶
   */
  logSecurityEvent(event, severity, details = {}) {
    this.logger.warn('å®‰å…¨äº‹ä»¶', {
      type: 'security_event',
      event,
      severity,
      details,
      timestamp: new Date().toISOString()
    });
  }
  
  /**
   * è®°å½•ç³»ç»Ÿé”™è¯¯
   */
  logError(error, context = {}) {
    this.logger.error('ç³»ç»Ÿé”™è¯¯', {
      type: 'system_error',
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name
      },
      context,
      timestamp: new Date().toISOString()
    });
  }
  
  /**
   * è®°å½•APIè®¿é—®æ—¥å¿—
   */
  logAPIAccess(req, res, duration) {
    this.logger.info('APIè®¿é—®', {
      type: 'api_access',
      method: req.method,
      path: req.path,
      statusCode: res.statusCode,
      duration,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      userId: req.user ? req.user.id : null,
      timestamp: new Date().toISOString()
    });
  }
}

// å…¨å±€æ—¥å¿—å®ä¾‹
const logManager = new LogManager();

module.exports = logManager;
```

### 2. æ—¥å¿—åˆ†æ

#### æ—¥å¿—æŸ¥è¯¢å’Œåˆ†æ
```javascript
/**
 * æ—¥å¿—åˆ†ææœåŠ¡
 */
class LogAnalysisService {
  constructor(elasticsearchClient) {
    this.es = elasticsearchClient;
  }
  
  /**
   * æŸ¥è¯¢é”™è¯¯æ—¥å¿—
   */
  async getErrorLogs(timeRange = '1h', limit = 100) {
    const query = {
      index: 'wallet-logs',
      body: {
        query: {
          bool: {
            must: [
              { term: { level: 'error' } },
              {
                range: {
                  '@timestamp': {
                    gte: `now-${timeRange}`
                  }
                }
              }
            ]
          }
        },
        sort: [
          { '@timestamp': { order: 'desc' } }
        ],
        size: limit
      }
    };
    
    const response = await this.es.search(query);
    return response.body.hits.hits.map(hit => hit._source);
  }
  
  /**
   * åˆ†æç”¨æˆ·è¡Œä¸ºæ¨¡å¼
   */
  async analyzeUserBehavior(userId, timeRange = '24h') {
    const query = {
      index: 'wallet-logs',
      body: {
        query: {
          bool: {
            must: [
              { term: { 'meta.userId': userId } },
              { term: { 'meta.type': 'user_action' } },
              {
                range: {
                  '@timestamp': {
                    gte: `now-${timeRange}`
                  }
                }
              }
            ]
          }
        },
        aggs: {
          actions: {
            terms: {
              field: 'meta.action.keyword',
              size: 20
            }
          },
          timeline: {
            date_histogram: {
              field: '@timestamp',
              interval: '1h'
            }
          }
        }
      }
    };
    
    const response = await this.es.search(query);
    return {
      actions: response.body.aggregations.actions.buckets,
      timeline: response.body.aggregations.timeline.buckets
    };
  }
  
  /**
   * æ£€æµ‹å¼‚å¸¸è®¿é—®æ¨¡å¼
   */
  async detectAnomalousAccess(timeRange = '1h') {
    const query = {
      index: 'wallet-logs',
      body: {
        query: {
          bool: {
            must: [
              { term: { 'meta.type': 'api_access' } },
              {
                range: {
                  '@timestamp': {
                    gte: `now-${timeRange}`
                  }
                }
              }
            ]
          }
        },
        aggs: {
          by_ip: {
            terms: {
              field: 'meta.ip.keyword',
              size: 100,
              order: { _count: 'desc' }
            },
            aggs: {
              request_count: {
                value_count: {
                  field: 'meta.ip.keyword'
                }
              }
            }
          },
          by_user_agent: {
            terms: {
              field: 'meta.userAgent.keyword',
              size: 50
            }
          }
        }
      }
    };
    
    const response = await this.es.search(query);
    
    // æ£€æµ‹é«˜é¢‘è®¿é—®IP
    const suspiciousIPs = response.body.aggregations.by_ip.buckets
      .filter(bucket => bucket.doc_count > 1000) // 1å°æ—¶å†…è¶…è¿‡1000æ¬¡è¯·æ±‚
      .map(bucket => ({
        ip: bucket.key,
        requestCount: bucket.doc_count
      }));
    
    return {
      suspiciousIPs,
      userAgents: response.body.aggregations.by_user_agent.buckets
    };
  }
}
```

## å¯è§†åŒ–ä»ªè¡¨æ¿

### 1. å®æ—¶ç›‘æ§é¢æ¿

#### Grafanaä»ªè¡¨æ¿é…ç½®
```json
{
  "dashboard": {
    "title": "æ•°å­—é’±åŒ…ç³»ç»Ÿç›‘æ§",
    "tags": ["wallet", "monitoring"],
    "timezone": "browser",
    "panels": [
      {
        "id": 1,
        "title": "ç³»ç»Ÿæ¦‚è§ˆ",
        "type": "stat",
        "targets": [
          {
            "query": "from(bucket: \"wallet-metrics\") |> range(start: -5m) |> filter(fn: (r) => r._measurement == \"system_cpu\" and r._field == \"usage_percent\") |> last()",
            "refId": "A"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "color": {
              "mode": "thresholds"
            },
            "thresholds": {
              "steps": [
                {"color": "green", "value": null},
                {"color": "yellow", "value": 70},
                {"color": "red", "value": 85}
              ]
            }
          }
        }
      },
      {
        "id": 2,
        "title": "äº¤æ˜“è¶‹åŠ¿",
        "type": "timeseries",
        "targets": [
          {
            "query": "from(bucket: \"wallet-metrics\") |> range(start: -24h) |> filter(fn: (r) => r._measurement == \"business_transactions\") |> aggregateWindow(every: 1h, fn: sum)",
            "refId": "B"
          }
        ]
      },
      {
        "id": 3,
        "title": "APIæ€§èƒ½",
        "type": "heatmap",
        "targets": [
          {
            "query": "from(bucket: \"wallet-metrics\") |> range(start: -1h) |> filter(fn: (r) => r._measurement == \"api_performance\" and r._field == \"duration_ms\")",
            "refId": "C"
          }
        ]
      }
    ]
  }
}
```

### 2. è‡ªå®šä¹‰ç›‘æ§é¢æ¿

#### Reactç›‘æ§ç»„ä»¶
```jsx
/**
 * å®æ—¶ç›‘æ§ä»ªè¡¨æ¿ç»„ä»¶
 */
import React, { useState, useEffect } from 'react';
import { Line, Bar, Doughnut } from 'react-chartjs-2';
import io from 'socket.io-client';

const MonitoringDashboard = () => {
  const [systemMetrics, setSystemMetrics] = useState({});
  const [businessMetrics, setBusinessMetrics] = useState({});
  const [alerts, setAlerts] = useState([]);
  
  useEffect(() => {
    // å»ºç«‹WebSocketè¿æ¥è·å–å®æ—¶æ•°æ®
    const socket = io('/monitoring');
    
    socket.on('system-metrics', (data) => {
      setSystemMetrics(data);
    });
    
    socket.on('business-metrics', (data) => {
      setBusinessMetrics(data);
    });
    
    socket.on('new-alert', (alert) => {
      setAlerts(prev => [alert, ...prev.slice(0, 9)]);
    });
    
    return () => socket.disconnect();
  }, []);
  
  return (
    <div className="monitoring-dashboard">
      <div className="dashboard-header">
        <h1>ç³»ç»Ÿç›‘æ§ä»ªè¡¨æ¿</h1>
        <div className="status-indicators">
          <StatusIndicator 
            label="ç³»ç»ŸçŠ¶æ€" 
            status={getSystemStatus(systemMetrics)} 
          />
          <StatusIndicator 
            label="ä¸šåŠ¡çŠ¶æ€" 
            status={getBusinessStatus(businessMetrics)} 
          />
        </div>
      </div>
      
      <div className="metrics-grid">
        {/* ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡ */}
        <div className="metric-card">
          <h3>CPUä½¿ç”¨ç‡</h3>
          <div className="metric-value">
            {systemMetrics.cpu?.usage?.toFixed(1)}%
          </div>
          <Line 
            data={getCPUChartData(systemMetrics.cpu?.history)} 
            options={chartOptions}
          />
        </div>
        
        <div className="metric-card">
          <h3>å†…å­˜ä½¿ç”¨ç‡</h3>
          <div className="metric-value">
            {systemMetrics.memory?.usage?.toFixed(1)}%
          </div>
          <Line 
            data={getMemoryChartData(systemMetrics.memory?.history)} 
            options={chartOptions}
          />
        </div>
        
        {/* ä¸šåŠ¡æŒ‡æ ‡ */}
        <div className="metric-card">
          <h3>ä»Šæ—¥äº¤æ˜“</h3>
          <div className="metric-value">
            {businessMetrics.transactions?.today?.total || 0}
          </div>
          <Bar 
            data={getTransactionChartData(businessMetrics.transactions)} 
            options={chartOptions}
          />
        </div>
        
        <div className="metric-card">
          <h3>ç”¨æˆ·åˆ†å¸ƒ</h3>
          <Doughnut 
            data={getUserDistributionData(businessMetrics.users)} 
            options={doughnutOptions}
          />
        </div>
        
        {/* APIæ€§èƒ½ */}
        <div className="metric-card full-width">
          <h3>APIå“åº”æ—¶é—´</h3>
          <Line 
            data={getAPIPerformanceData(systemMetrics.api)} 
            options={apiChartOptions}
          />
        </div>
        
        {/* å‘Šè­¦åˆ—è¡¨ */}
        <div className="alert-panel">
          <h3>æœ€æ–°å‘Šè­¦</h3>
          <div className="alert-list">
            {alerts.map(alert => (
              <AlertItem key={alert.id} alert={alert} />
            ))}
          </div>
        </div>
      </div>
    </div>
  );
};

/**
 * çŠ¶æ€æŒ‡ç¤ºå™¨ç»„ä»¶
 */
const StatusIndicator = ({ label, status }) => {
  const statusColors = {
    healthy: '#4CAF50',
    warning: '#FF9800',
    critical: '#F44336'
  };
  
  return (
    <div className="status-indicator">
      <div 
        className="status-dot" 
        style={{ backgroundColor: statusColors[status] }}
      />
      <span>{label}</span>
    </div>
  );
};

/**
 * å‘Šè­¦é¡¹ç»„ä»¶
 */
const AlertItem = ({ alert }) => {
  const severityIcons = {
    critical: 'ğŸ”´',
    warning: 'ğŸŸ¡',
    info: 'ğŸ”µ'
  };
  
  return (
    <div className={`alert-item ${alert.severity}`}>
      <div className="alert-header">
        <span className="alert-icon">
          {severityIcons[alert.severity]}
        </span>
        <span className="alert-title">{alert.ruleName}</span>
        <span className="alert-time">
          {new Date(alert.timestamp).toLocaleTimeString()}
        </span>
      </div>
      <div className="alert-description">
        {alert.description}
      </div>
    </div>
  );
};

// å›¾è¡¨é…ç½®
const chartOptions = {
  responsive: true,
  maintainAspectRatio: false,
  scales: {
    y: {
      beginAtZero: true
    }
  }
};

const apiChartOptions = {
  ...chartOptions,
  scales: {
    y: {
      beginAtZero: true,
      title: {
        display: true,
        text: 'å“åº”æ—¶é—´ (ms)'
      }
    }
  }
};

const doughnutOptions = {
  responsive: true,
  maintainAspectRatio: false,
  plugins: {
    legend: {
      position: 'bottom'
    }
  }
};

export default MonitoringDashboard;
```

## éƒ¨ç½²å’Œè¿ç»´

### 1. Dockerå®¹å™¨åŒ–éƒ¨ç½²

#### ç›‘æ§ç³»ç»ŸDockeré…ç½®
```dockerfile
# ç›‘æ§æœåŠ¡Dockerfile
FROM node:18-alpine

WORKDIR /app

# å®‰è£…ä¾èµ–
COPY package*.json ./
RUN npm ci --only=production

# å¤åˆ¶æºä»£ç 
COPY . .

# åˆ›å»ºæ—¥å¿—ç›®å½•
RUN mkdir -p logs

# è®¾ç½®æƒé™
RUN chown -R node:node /app
USER node

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js

EXPOSE 3001

CMD ["node", "monitoring-server.js"]
```

#### Docker Composeé…ç½®
```yaml
version: '3.8'

services:
  # ç›‘æ§æœåŠ¡
  monitoring:
    build: .
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=production
      - INFLUXDB_URL=http://influxdb:8086
      - INFLUXDB_TOKEN=${INFLUXDB_TOKEN}
      - ELASTICSEARCH_URL=http://elasticsearch:9200
    depends_on:
      - influxdb
      - elasticsearch
      - redis
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
  
  # InfluxDBæ—¶åºæ•°æ®åº“
  influxdb:
    image: influxdb:2.7-alpine
    ports:
      - "8086:8086"
    environment:
      - INFLUXDB_DB=wallet_metrics
      - INFLUXDB_ADMIN_USER=${INFLUXDB_USER}
      - INFLUXDB_ADMIN_PASSWORD=${INFLUXDB_PASSWORD}
    volumes:
      - influxdb_data:/var/lib/influxdb2
    restart: unless-stopped
  
  # Elasticsearchæ—¥å¿—å­˜å‚¨
  elasticsearch:
    image: elasticsearch:8.11.0
    ports:
      - "9200:9200"
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    restart: unless-stopped
  
  # Grafanaå¯è§†åŒ–
  grafana:
    image: grafana/grafana:10.2.0
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
      - ./grafana/datasources:/etc/grafana/provisioning/datasources
    restart: unless-stopped
  
  # Redisç¼“å­˜
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

volumes:
  influxdb_data:
  elasticsearch_data:
  grafana_data:
  redis_data:
```

### 2. ç›‘æ§ç³»ç»Ÿç»´æŠ¤

#### è‡ªåŠ¨åŒ–è¿ç»´è„šæœ¬
```bash
#!/bin/bash
# monitoring-maintenance.sh - ç›‘æ§ç³»ç»Ÿç»´æŠ¤è„šæœ¬

set -e

# é…ç½®
BACKUP_DIR="/backup/monitoring"
LOG_DIR="/app/logs"
RETENTION_DAYS=30

# åˆ›å»ºå¤‡ä»½ç›®å½•
mkdir -p $BACKUP_DIR

# æ•°æ®å¤‡ä»½
backup_data() {
    echo "å¼€å§‹å¤‡ä»½ç›‘æ§æ•°æ®..."
    
    # å¤‡ä»½InfluxDBæ•°æ®
    docker exec monitoring_influxdb_1 influx backup \
        --bucket wallet_metrics \
        --org myorg \
        /tmp/backup
    
    docker cp monitoring_influxdb_1:/tmp/backup \
        $BACKUP_DIR/influxdb_$(date +%Y%m%d_%H%M%S)
    
    # å¤‡ä»½Grafanaé…ç½®
    docker exec monitoring_grafana_1 tar czf /tmp/grafana_backup.tar.gz \
        /var/lib/grafana
    
    docker cp monitoring_grafana_1:/tmp/grafana_backup.tar.gz \
        $BACKUP_DIR/grafana_$(date +%Y%m%d_%H%M%S).tar.gz
    
    echo "æ•°æ®å¤‡ä»½å®Œæˆ"
}

# æ¸…ç†æ—§æ—¥å¿—
cleanup_logs() {
    echo "æ¸…ç†æ—§æ—¥å¿—æ–‡ä»¶..."
    
    find $LOG_DIR -name "*.log" -mtime +$RETENTION_DAYS -delete
    
    # æ¸…ç†Elasticsearchæ—§ç´¢å¼•
    docker exec monitoring_elasticsearch_1 \
        curl -X DELETE "localhost:9200/wallet-logs-$(date -d '30 days ago' +%Y.%m.%d)"
    
    echo "æ—¥å¿—æ¸…ç†å®Œæˆ"
}

# ç³»ç»Ÿå¥åº·æ£€æŸ¥
health_check() {
    echo "æ‰§è¡Œç³»ç»Ÿå¥åº·æ£€æŸ¥..."
    
    # æ£€æŸ¥æœåŠ¡çŠ¶æ€
    services=("monitoring" "influxdb" "elasticsearch" "grafana" "redis")
    
    for service in "${services[@]}"; do
        if docker ps | grep -q "monitoring_${service}_1"; then
            echo "âœ“ $service æœåŠ¡è¿è¡Œæ­£å¸¸"
        else
            echo "âœ— $service æœåŠ¡å¼‚å¸¸"
            # å°è¯•é‡å¯æœåŠ¡
            docker-compose restart $service
        fi
    done
    
    # æ£€æŸ¥ç£ç›˜ç©ºé—´
    disk_usage=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
    if [ $disk_usage -gt 85 ]; then
        echo "âš ï¸  ç£ç›˜ä½¿ç”¨ç‡è¿‡é«˜: ${disk_usage}%"
        # å‘é€å‘Šè­¦
        curl -X POST $WEBHOOK_URL \
            -H 'Content-Type: application/json' \
            -d "{\"text\":\"ç›‘æ§æœåŠ¡å™¨ç£ç›˜ä½¿ç”¨ç‡è¿‡é«˜: ${disk_usage}%\"}"
    fi
    
    echo "å¥åº·æ£€æŸ¥å®Œæˆ"
}

# æ€§èƒ½ä¼˜åŒ–
optimize_performance() {
    echo "æ‰§è¡Œæ€§èƒ½ä¼˜åŒ–..."
    
    # ä¼˜åŒ–Elasticsearch
    docker exec monitoring_elasticsearch_1 \
        curl -X POST "localhost:9200/_forcemerge?max_num_segments=1"
    
    # æ¸…ç†Redisè¿‡æœŸé”®
    docker exec monitoring_redis_1 redis-cli FLUSHEXPIRED
    
    echo "æ€§èƒ½ä¼˜åŒ–å®Œæˆ"
}

# ä¸»å‡½æ•°
main() {
    case "$1" in
        backup)
            backup_data
            ;;
        cleanup)
            cleanup_logs
            ;;
        health)
            health_check
            ;;
        optimize)
            optimize_performance
            ;;
        all)
            backup_data
            cleanup_logs
            health_check
            optimize_performance
            ;;
        *)
            echo "ç”¨æ³•: $0 {backup|cleanup|health|optimize|all}"
            exit 1
            ;;
    esac
}

main "$@"
```

## æ€»ç»“

æœ¬å®æ—¶ç›‘æ§ç³»ç»Ÿè®¾è®¡æ–‡æ¡£æä¾›äº†å®Œæ•´çš„ç›‘æ§è§£å†³æ–¹æ¡ˆï¼š

### æ ¸å¿ƒåŠŸèƒ½
1. **å…¨é¢ç›‘æ§** - ç³»ç»Ÿæ€§èƒ½ã€ä¸šåŠ¡æŒ‡æ ‡ã€APIæ€§èƒ½ã€å®‰å…¨äº‹ä»¶
2. **æ™ºèƒ½å‘Šè­¦** - å¤šçº§åˆ«å‘Šè­¦è§„åˆ™ã€å¤šæ¸ é“é€šçŸ¥
3. **æ—¥å¿—ç®¡ç†** - ç»“æ„åŒ–æ—¥å¿—ã€å®æ—¶åˆ†æã€å¼‚å¸¸æ£€æµ‹
4. **å¯è§†åŒ–å±•ç¤º** - å®æ—¶ä»ªè¡¨æ¿ã€å†å²æŠ¥è¡¨ã€ç§»åŠ¨ç«¯æ”¯æŒ

### æŠ€æœ¯ç‰¹ç‚¹
- é«˜æ€§èƒ½æ—¶åºæ•°æ®å­˜å‚¨
- å®æ—¶æ•°æ®å¤„ç†å’Œåˆ†æ
- çµæ´»çš„å‘Šè­¦è§„åˆ™é…ç½®
- å¤šæ¸ é“é€šçŸ¥æœºåˆ¶
- å®¹å™¨åŒ–éƒ¨ç½²å’Œè‡ªåŠ¨åŒ–è¿ç»´

### é¢„æœŸæ•ˆæœ
- ç³»ç»Ÿå¯ç”¨æ€§æå‡è‡³99.9%ä»¥ä¸Š
- æ•…éšœå‘ç°æ—¶é—´ç¼©çŸ­è‡³1åˆ†é’Ÿå†…
- å‘Šè­¦å‡†ç¡®ç‡è¾¾åˆ°95%ä»¥ä¸Š
- æ—¥å¿—æŸ¥è¯¢å“åº”æ—¶é—´å°äº3ç§’
- æ”¯æŒ10ä¸‡+å¹¶å‘ç”¨æˆ·ç›‘æ§

### å®æ–½è®¡åˆ’
1. **ç¬¬ä¸€é˜¶æ®µï¼ˆ1-2å‘¨ï¼‰** - åŸºç¡€ç›‘æ§æ­å»º
2. **ç¬¬äºŒé˜¶æ®µï¼ˆ2-3å‘¨ï¼‰** - å‘Šè­¦ç³»ç»Ÿå®Œå–„
3. **ç¬¬ä¸‰é˜¶æ®µï¼ˆ1-2å‘¨ï¼‰** - å¯è§†åŒ–ç•Œé¢å¼€å‘
4. **ç¬¬å››é˜¶æ®µï¼ˆ1å‘¨ï¼‰** - æµ‹è¯•å’Œä¼˜åŒ–

é€šè¿‡æœ¬ç›‘æ§ç³»ç»Ÿï¼Œå¯ä»¥å®ç°å¯¹æ•°å­—é’±åŒ…ç®¡ç†åå°çš„å…¨æ–¹ä½ç›‘æ§ï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®šè¿è¡Œå’Œä¸šåŠ¡è¿ç»­æ€§ã€‚