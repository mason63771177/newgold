# Tatum 钱包服务安全配置指南

## 概述

本指南提供了 Tatum 中心化钱包服务的全面安全配置建议，涵盖了从基础设施到应用层的各个安全方面。

## 🔐 核心安全原则

### 1. 最小权限原则
- 每个组件只获得完成其功能所需的最小权限
- 定期审查和调整权限设置
- 使用专用服务账户，避免使用 root 权限

### 2. 深度防御
- 多层安全控制，单点失败不会导致整体安全失效
- 网络隔离、应用防护、数据加密多重保护

### 3. 零信任架构
- 不信任任何内部或外部的网络流量
- 所有访问都需要验证和授权

## 🏗️ 基础设施安全

### 服务器安全配置

#### 操作系统加固
```bash
# 更新系统
sudo apt update && sudo apt upgrade -y

# 配置防火墙
sudo ufw enable
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow 22/tcp    # SSH
sudo ufw allow 80/tcp    # HTTP
sudo ufw allow 443/tcp   # HTTPS

# 禁用不必要的服务
sudo systemctl disable bluetooth
sudo systemctl disable cups
sudo systemctl disable avahi-daemon

# 配置 SSH 安全
sudo sed -i 's/#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config
sudo sed -i 's/#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config
sudo systemctl restart sshd
```

#### 用户管理
```bash
# 创建专用用户
sudo useradd -m -s /bin/bash tatum-wallet
sudo usermod -aG docker tatum-wallet

# 配置 sudo 权限（仅必要时）
echo "tatum-wallet ALL=(ALL) NOPASSWD: /usr/bin/docker, /usr/bin/docker-compose" | sudo tee /etc/sudoers.d/tatum-wallet
```

### 网络安全

#### 防火墙配置
```bash
# iptables 规则示例
sudo iptables -A INPUT -i lo -j ACCEPT
sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT
sudo iptables -A INPUT -j DROP
```

#### 网络隔离
- 使用 Docker 网络隔离服务
- 数据库和 Redis 不对外暴露端口
- 使用内部网络进行服务间通信

## 🔑 密钥和证书管理

### 助记词安全

#### 生成和存储
```javascript
// 使用安全的随机数生成器
const crypto = require('crypto');
const bip39 = require('bip39');

// 生成高熵助记词
const entropy = crypto.randomBytes(32);
const mnemonic = bip39.entropyToMnemonic(entropy);

// 验证助记词
if (!bip39.validateMnemonic(mnemonic)) {
    throw new Error('Invalid mnemonic generated');
}
```

#### 加密存储
```javascript
const crypto = require('crypto');

class SecureStorage {
    constructor(encryptionKey) {
        this.algorithm = 'aes-256-gcm';
        this.key = Buffer.from(encryptionKey, 'hex');
    }
    
    encrypt(text) {
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipher(this.algorithm, this.key);
        cipher.setAAD(Buffer.from('tatum-wallet', 'utf8'));
        
        let encrypted = cipher.update(text, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        const authTag = cipher.getAuthTag();
        
        return {
            encrypted,
            iv: iv.toString('hex'),
            authTag: authTag.toString('hex')
        };
    }
    
    decrypt(encryptedData) {
        const decipher = crypto.createDecipher(this.algorithm, this.key);
        decipher.setAAD(Buffer.from('tatum-wallet', 'utf8'));
        decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
        
        let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }
}
```

### SSL/TLS 证书

#### 生产环境证书配置
```bash
# 使用 Let's Encrypt 获取免费证书
sudo apt install certbot python3-certbot-nginx
sudo certbot --nginx -d your-domain.com

# 自动续期
sudo crontab -e
# 添加: 0 12 * * * /usr/bin/certbot renew --quiet
```

#### 证书安全配置
```nginx
# 强制 HTTPS
server {
    listen 80;
    server_name your-domain.com;
    return 301 https://$server_name$request_uri;
}

# HTTPS 配置
server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    # SSL 证书
    ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;
    
    # SSL 安全配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # HSTS
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
}
```

## 🛡️ 应用安全

### 环境变量安全

#### 敏感信息管理
```bash
# 使用 Docker Secrets（推荐）
echo "your_secret_key" | docker secret create tatum_api_key -
echo "your_mnemonic" | docker secret create master_wallet_mnemonic -

# 在 docker-compose.yml 中使用
services:
  tatum-wallet-service:
    secrets:
      - tatum_api_key
      - master_wallet_mnemonic
    environment:
      - TATUM_API_KEY_FILE=/run/secrets/tatum_api_key
      - MASTER_WALLET_MNEMONIC_FILE=/run/secrets/master_wallet_mnemonic

secrets:
  tatum_api_key:
    external: true
  master_wallet_mnemonic:
    external: true
```

#### 环境变量验证
```javascript
// config/security.js
const crypto = require('crypto');

class SecurityConfig {
    static validateEnvironment() {
        const required = [
            'TATUM_API_KEY',
            'MASTER_WALLET_MNEMONIC',
            'ENCRYPTION_KEY',
            'JWT_SECRET'
        ];
        
        for (const key of required) {
            if (!process.env[key]) {
                throw new Error(`Missing required environment variable: ${key}`);
            }
            
            // 检查密钥强度
            if (key.includes('KEY') || key.includes('SECRET')) {
                if (process.env[key].length < 32) {
                    throw new Error(`${key} must be at least 32 characters long`);
                }
            }
        }
    }
    
    static generateSecureKey() {
        return crypto.randomBytes(32).toString('hex');
    }
}

module.exports = SecurityConfig;
```

### API 安全

#### 请求验证和限流
```javascript
// middleware/security.js
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const cors = require('cors');

// 安全头设置
const securityHeaders = helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    }
});

// 限流配置
const createRateLimit = (windowMs, max, message) => {
    return rateLimit({
        windowMs,
        max,
        message: { error: message },
        standardHeaders: true,
        legacyHeaders: false,
    });
};

// 不同端点的限流策略
const rateLimits = {
    general: createRateLimit(15 * 60 * 1000, 100, 'Too many requests'),
    auth: createRateLimit(15 * 60 * 1000, 5, 'Too many authentication attempts'),
    wallet: createRateLimit(60 * 1000, 10, 'Too many wallet operations'),
    withdrawal: createRateLimit(60 * 1000, 3, 'Too many withdrawal attempts')
};

// CORS 配置
const corsOptions = {
    origin: process.env.CORS_ORIGIN?.split(',') || false,
    credentials: true,
    optionsSuccessStatus: 200
};

module.exports = {
    securityHeaders,
    rateLimits,
    cors: cors(corsOptions)
};
```

#### 输入验证和清理
```javascript
// middleware/validation.js
const Joi = require('joi');
const validator = require('validator');

const schemas = {
    withdrawal: Joi.object({
        userId: Joi.number().integer().positive().required(),
        amount: Joi.number().positive().precision(2).min(10).max(10000).required(),
        toAddress: Joi.string().custom((value, helpers) => {
            if (!validator.isLength(value, { min: 34, max: 34 })) {
                return helpers.error('any.invalid');
            }
            if (!value.startsWith('T')) {
                return helpers.error('any.invalid');
            }
            return value;
        }).required()
    }),
    
    depositAddress: Joi.object({
        userId: Joi.number().integer().positive().required()
    })
};

const validate = (schema) => {
    return (req, res, next) => {
        const { error } = schema.validate(req.body);
        if (error) {
            return res.status(400).json({
                error: 'Validation failed',
                details: error.details.map(d => d.message)
            });
        }
        next();
    };
};

module.exports = { schemas, validate };
```

## 🗄️ 数据库安全

### MySQL 安全配置

#### 用户权限管理
```sql
-- 创建专用数据库用户
CREATE USER 'wallet_user'@'%' IDENTIFIED BY 'strong_password_here';

-- 授予最小必要权限
GRANT SELECT, INSERT, UPDATE, DELETE ON gold7_game.* TO 'wallet_user'@'%';

-- 禁止危险操作
REVOKE CREATE, DROP, ALTER, INDEX ON *.* FROM 'wallet_user'@'%';

-- 刷新权限
FLUSH PRIVILEGES;
```

#### 数据加密
```sql
-- 启用数据加密
SET GLOBAL innodb_encrypt_tables = ON;
SET GLOBAL innodb_encrypt_log = ON;
SET GLOBAL innodb_encryption_threads = 4;

-- 敏感字段加密存储
ALTER TABLE user_wallets 
ADD COLUMN encrypted_private_key VARBINARY(512),
ADD COLUMN encryption_iv VARBINARY(16);
```

### Redis 安全配置

#### 认证和网络安全
```bash
# redis.conf 安全配置
requirepass your_strong_redis_password
bind 127.0.0.1
port 0
unixsocket /var/run/redis/redis.sock
unixsocketperm 700

# 禁用危险命令
rename-command FLUSHDB ""
rename-command FLUSHALL ""
rename-command KEYS ""
rename-command CONFIG "CONFIG_b835c3f8a5d9e7f2"
```

## 📊 监控和审计

### 安全日志记录

#### 日志配置
```javascript
// utils/securityLogger.js
const winston = require('winston');
const path = require('path');

const securityLogger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
    ),
    defaultMeta: { service: 'tatum-wallet-security' },
    transports: [
        new winston.transports.File({
            filename: path.join('logs', 'security.log'),
            level: 'info'
        }),
        new winston.transports.File({
            filename: path.join('logs', 'security-error.log'),
            level: 'error'
        })
    ]
});

// 安全事件记录
const logSecurityEvent = (event, details, req = null) => {
    const logData = {
        event,
        details,
        timestamp: new Date().toISOString(),
        ip: req?.ip || 'unknown',
        userAgent: req?.get('User-Agent') || 'unknown'
    };
    
    securityLogger.info('Security Event', logData);
};

module.exports = { securityLogger, logSecurityEvent };
```

#### 关键事件监控
```javascript
// middleware/securityMonitoring.js
const { logSecurityEvent } = require('../utils/securityLogger');

const monitorSecurityEvents = (req, res, next) => {
    // 监控敏感操作
    const sensitiveEndpoints = [
        '/api/wallet/withdraw',
        '/api/wallet/consolidate',
        '/api/admin'
    ];
    
    if (sensitiveEndpoints.some(endpoint => req.path.startsWith(endpoint))) {
        logSecurityEvent('SENSITIVE_OPERATION', {
            endpoint: req.path,
            method: req.method,
            userId: req.user?.id
        }, req);
    }
    
    // 监控异常请求
    if (req.body && JSON.stringify(req.body).length > 10000) {
        logSecurityEvent('LARGE_REQUEST_BODY', {
            size: JSON.stringify(req.body).length,
            endpoint: req.path
        }, req);
    }
    
    next();
};

module.exports = monitorSecurityEvents;
```

### 入侵检测

#### 异常行为检测
```javascript
// services/intrusionDetection.js
const Redis = require('redis');
const { logSecurityEvent } = require('../utils/securityLogger');

class IntrusionDetection {
    constructor() {
        this.redis = Redis.createClient();
        this.thresholds = {
            failedLogins: 5,
            rapidRequests: 100,
            timeWindow: 300 // 5 minutes
        };
    }
    
    async checkFailedLogins(ip, userId = null) {
        const key = `failed_login:${ip}:${userId || 'anonymous'}`;
        const count = await this.redis.incr(key);
        await this.redis.expire(key, this.thresholds.timeWindow);
        
        if (count >= this.thresholds.failedLogins) {
            logSecurityEvent('BRUTE_FORCE_DETECTED', {
                ip,
                userId,
                attempts: count
            });
            
            // 触发自动封禁
            await this.blockIP(ip, 3600); // 1 hour
            return true;
        }
        
        return false;
    }
    
    async checkRapidRequests(ip) {
        const key = `rapid_requests:${ip}`;
        const count = await this.redis.incr(key);
        await this.redis.expire(key, 60); // 1 minute window
        
        if (count >= this.thresholds.rapidRequests) {
            logSecurityEvent('RAPID_REQUESTS_DETECTED', {
                ip,
                requests: count
            });
            
            return true;
        }
        
        return false;
    }
    
    async blockIP(ip, duration) {
        const key = `blocked_ip:${ip}`;
        await this.redis.setex(key, duration, '1');
        
        logSecurityEvent('IP_BLOCKED', {
            ip,
            duration
        });
    }
    
    async isIPBlocked(ip) {
        const key = `blocked_ip:${ip}`;
        return await this.redis.exists(key);
    }
}

module.exports = IntrusionDetection;
```

## 🔄 安全更新和维护

### 定期安全检查

#### 自动化安全扫描脚本
```bash
#!/bin/bash
# scripts/security-scan.sh

echo "开始安全扫描..."

# 检查系统更新
echo "检查系统更新..."
apt list --upgradable

# 检查 Docker 镜像漏洞
echo "扫描 Docker 镜像漏洞..."
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
    aquasec/trivy image tatum-wallet-service:latest

# 检查 Node.js 依赖漏洞
echo "检查 Node.js 依赖漏洞..."
npm audit

# 检查端口开放情况
echo "检查开放端口..."
nmap -sT -O localhost

# 检查文件权限
echo "检查关键文件权限..."
find . -name "*.key" -o -name "*.pem" -o -name ".env*" | xargs ls -la

echo "安全扫描完成"
```

### 应急响应计划

#### 安全事件响应流程
```javascript
// services/incidentResponse.js
const { logSecurityEvent } = require('../utils/securityLogger');
const { sendAlert } = require('./alerting');

class IncidentResponse {
    static async handleSecurityIncident(incident) {
        const { type, severity, details } = incident;
        
        // 记录事件
        logSecurityEvent('SECURITY_INCIDENT', {
            type,
            severity,
            details,
            responseTime: new Date().toISOString()
        });
        
        // 根据严重程度采取行动
        switch (severity) {
            case 'CRITICAL':
                await this.criticalIncidentResponse(incident);
                break;
            case 'HIGH':
                await this.highIncidentResponse(incident);
                break;
            case 'MEDIUM':
                await this.mediumIncidentResponse(incident);
                break;
            default:
                await this.lowIncidentResponse(incident);
        }
    }
    
    static async criticalIncidentResponse(incident) {
        // 立即通知管理员
        await sendAlert('CRITICAL_SECURITY_INCIDENT', incident);
        
        // 考虑暂停服务
        if (incident.type === 'WALLET_COMPROMISE') {
            await this.emergencyShutdown();
        }
    }
    
    static async emergencyShutdown() {
        logSecurityEvent('EMERGENCY_SHUTDOWN', {
            reason: 'Security incident response',
            timestamp: new Date().toISOString()
        });
        
        // 停止处理新的交易
        process.env.EMERGENCY_MODE = 'true';
        
        // 通知所有相关人员
        await sendAlert('EMERGENCY_SHUTDOWN', {
            message: 'Service has been shut down due to security incident'
        });
    }
}

module.exports = IncidentResponse;
```

## 📋 安全检查清单

### 部署前检查
- [ ] 所有默认密码已更改
- [ ] 环境变量已正确配置
- [ ] SSL/TLS 证书已安装并配置
- [ ] 防火墙规则已设置
- [ ] 数据库用户权限已限制
- [ ] Redis 认证已启用
- [ ] 日志记录已配置
- [ ] 监控和告警已设置

### 运行时检查
- [ ] 定期更新系统和依赖
- [ ] 监控安全日志
- [ ] 检查异常访问模式
- [ ] 验证备份完整性
- [ ] 测试应急响应流程
- [ ] 审查用户权限
- [ ] 检查证书有效期

### 定期审计
- [ ] 代码安全审计
- [ ] 渗透测试
- [ ] 依赖漏洞扫描
- [ ] 配置安全检查
- [ ] 访问日志分析
- [ ] 权限审查
- [ ] 备份恢复测试

## 🚨 紧急联系信息

### 安全事件报告
- **技术负责人**: [联系方式]
- **安全团队**: [联系方式]
- **运维团队**: [联系方式]

### 外部资源
- **Tatum 技术支持**: support@tatum.io
- **安全漏洞报告**: security@tatum.io
- **紧急响应服务**: [第三方安全服务商]

---

**重要提醒**: 安全是一个持续的过程，需要定期评估和更新安全措施。请确保所有团队成员都了解并遵循这些安全准则。