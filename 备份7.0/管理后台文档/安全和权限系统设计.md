# 🔐 管理后台安全和权限系统设计

## 概述

本文档详细设计了数字钱包管理后台的安全和权限系统，采用基于角色的访问控制(RBAC)模型，结合多层安全防护机制，确保管理后台系统的安全性、可控性和合规性。

## 安全架构设计

### 1. 多层安全防护架构

```
┌─────────────────────────────────────────────────────────────┐
│                    网络安全层                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   防火墙    │  │   WAF防护   │  │  DDoS防护   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    应用安全层                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  API网关    │  │  速率限制   │  │  请求验证   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    认证授权层                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  身份认证   │  │  权限验证   │  │  会话管理   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    数据安全层                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  数据加密   │  │  数据脱敏   │  │  审计日志   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

### 2. 核心安全组件

#### 身份认证服务 (Authentication Service)
```javascript
/**
 * 身份认证服务
 * 支持多种认证方式：用户名密码、双因素认证、SSO
 */
class AuthenticationService {
  /**
   * 用户登录认证
   * @param {string} username - 用户名
   * @param {string} password - 密码
   * @param {string} totpCode - TOTP验证码(可选)
   * @returns {Object} 认证结果
   */
  async authenticate(username, password, totpCode = null) {
    // 1. 基础认证
    const user = await this.validateCredentials(username, password);
    if (!user) {
      throw new AuthenticationError('用户名或密码错误');
    }
    
    // 2. 账户状态检查
    if (user.status !== 'active') {
      throw new AuthenticationError('账户已被禁用');
    }
    
    // 3. 双因素认证
    if (user.twoFactorEnabled && !totpCode) {
      throw new TwoFactorRequiredError('需要双因素认证');
    }
    
    if (user.twoFactorEnabled) {
      const isValidTotp = await this.verifyTOTP(user.id, totpCode);
      if (!isValidTotp) {
        throw new AuthenticationError('双因素认证码错误');
      }
    }
    
    // 4. 登录限制检查
    await this.checkLoginRestrictions(user.id);
    
    // 5. 生成访问令牌
    const tokens = await this.generateTokens(user);
    
    // 6. 记录登录日志
    await this.logLoginAttempt(user.id, 'success');
    
    return {
      user: this.sanitizeUserData(user),
      tokens,
      permissions: await this.getUserPermissions(user.id)
    };
  }
  
  /**
   * 验证访问令牌
   * @param {string} token - JWT令牌
   * @returns {Object} 用户信息和权限
   */
  async verifyToken(token) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // 检查令牌是否在黑名单中
      const isBlacklisted = await redis.get(`blacklist:${token}`);
      if (isBlacklisted) {
        throw new TokenError('令牌已失效');
      }
      
      // 获取用户最新信息
      const user = await User.findById(decoded.userId);
      if (!user || user.status !== 'active') {
        throw new TokenError('用户不存在或已被禁用');
      }
      
      return {
        user: this.sanitizeUserData(user),
        permissions: await this.getUserPermissions(user.id)
      };
      
    } catch (error) {
      throw new TokenError('令牌验证失败');
    }
  }
}
```

#### 权限管理服务 (Authorization Service)
```javascript
/**
 * 权限管理服务
 * 实现RBAC权限控制模型
 */
class AuthorizationService {
  /**
   * 检查用户权限
   * @param {number} userId - 用户ID
   * @param {string} permission - 权限标识
   * @param {Object} context - 上下文信息
   * @returns {boolean} 是否有权限
   */
  async checkPermission(userId, permission, context = {}) {
    // 1. 获取用户角色
    const userRoles = await this.getUserRoles(userId);
    
    // 2. 获取角色权限
    const rolePermissions = await this.getRolePermissions(userRoles);
    
    // 3. 检查直接权限
    if (rolePermissions.includes(permission)) {
      return true;
    }
    
    // 4. 检查上下文权限
    const contextPermissions = await this.getContextPermissions(
      userId, permission, context
    );
    
    return contextPermissions.some(p => p.permission === permission);
  }
  
  /**
   * 获取用户所有权限
   * @param {number} userId - 用户ID
   * @returns {Array} 权限列表
   */
  async getUserPermissions(userId) {
    const cacheKey = `user_permissions:${userId}`;
    
    // 尝试从缓存获取
    let permissions = await redis.get(cacheKey);
    if (permissions) {
      return JSON.parse(permissions);
    }
    
    // 从数据库获取
    const query = `
      SELECT DISTINCT p.code, p.name, p.resource, p.action
      FROM permissions p
      JOIN role_permissions rp ON p.id = rp.permission_id
      JOIN user_roles ur ON rp.role_id = ur.role_id
      WHERE ur.user_id = ? AND ur.status = 'active'
      AND p.status = 'active'
    `;
    
    permissions = await db.query(query, [userId]);
    
    // 缓存权限信息(5分钟)
    await redis.setex(cacheKey, 300, JSON.stringify(permissions));
    
    return permissions;
  }
  
  /**
   * 权限验证中间件
   * @param {string} permission - 需要的权限
   * @returns {Function} Express中间件
   */
  requirePermission(permission) {
    return async (req, res, next) => {
      try {
        const hasPermission = await this.checkPermission(
          req.user.id, 
          permission, 
          req.context
        );
        
        if (!hasPermission) {
          return res.status(403).json({
            success: false,
            code: 403,
            message: '权限不足',
            error: {
              type: 'PERMISSION_DENIED',
              permission: permission
            }
          });
        }
        
        next();
      } catch (error) {
        return res.status(500).json({
          success: false,
          code: 500,
          message: '权限验证失败'
        });
      }
    };
  }
}
```

## RBAC权限模型设计

### 1. 数据库表结构

#### 用户表 (admin_users)
```sql
CREATE TABLE admin_users (
  id INT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(50) UNIQUE NOT NULL COMMENT '用户名',
  email VARCHAR(100) UNIQUE NOT NULL COMMENT '邮箱',
  password_hash VARCHAR(255) NOT NULL COMMENT '密码哈希',
  salt VARCHAR(32) NOT NULL COMMENT '密码盐值',
  real_name VARCHAR(50) COMMENT '真实姓名',
  phone VARCHAR(20) COMMENT '手机号',
  avatar_url VARCHAR(255) COMMENT '头像URL',
  status ENUM('active', 'inactive', 'locked') DEFAULT 'active' COMMENT '状态',
  two_factor_enabled BOOLEAN DEFAULT FALSE COMMENT '是否启用双因素认证',
  two_factor_secret VARCHAR(32) COMMENT '双因素认证密钥',
  last_login_at TIMESTAMP COMMENT '最后登录时间',
  last_login_ip VARCHAR(45) COMMENT '最后登录IP',
  login_attempts INT DEFAULT 0 COMMENT '登录尝试次数',
  locked_until TIMESTAMP NULL COMMENT '锁定到期时间',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by INT COMMENT '创建者ID',
  
  INDEX idx_username (username),
  INDEX idx_email (email),
  INDEX idx_status (status),
  INDEX idx_last_login (last_login_at)
) COMMENT '管理员用户表';
```

#### 角色表 (admin_roles)
```sql
CREATE TABLE admin_roles (
  id INT PRIMARY KEY AUTO_INCREMENT,
  code VARCHAR(50) UNIQUE NOT NULL COMMENT '角色代码',
  name VARCHAR(100) NOT NULL COMMENT '角色名称',
  description TEXT COMMENT '角色描述',
  level INT DEFAULT 0 COMMENT '角色级别(数字越大权限越高)',
  status ENUM('active', 'inactive') DEFAULT 'active' COMMENT '状态',
  is_system BOOLEAN DEFAULT FALSE COMMENT '是否系统角色',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  created_by INT COMMENT '创建者ID',
  
  INDEX idx_code (code),
  INDEX idx_status (status),
  INDEX idx_level (level)
) COMMENT '管理员角色表';
```

#### 权限表 (admin_permissions)
```sql
CREATE TABLE admin_permissions (
  id INT PRIMARY KEY AUTO_INCREMENT,
  code VARCHAR(100) UNIQUE NOT NULL COMMENT '权限代码',
  name VARCHAR(100) NOT NULL COMMENT '权限名称',
  description TEXT COMMENT '权限描述',
  resource VARCHAR(50) NOT NULL COMMENT '资源类型',
  action VARCHAR(50) NOT NULL COMMENT '操作类型',
  module VARCHAR(50) NOT NULL COMMENT '所属模块',
  status ENUM('active', 'inactive') DEFAULT 'active' COMMENT '状态',
  is_system BOOLEAN DEFAULT FALSE COMMENT '是否系统权限',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  INDEX idx_code (code),
  INDEX idx_resource (resource),
  INDEX idx_module (module),
  INDEX idx_status (status),
  UNIQUE KEY uk_resource_action (resource, action)
) COMMENT '管理员权限表';
```

#### 用户角色关联表 (admin_user_roles)
```sql
CREATE TABLE admin_user_roles (
  id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT NOT NULL COMMENT '用户ID',
  role_id INT NOT NULL COMMENT '角色ID',
  status ENUM('active', 'inactive') DEFAULT 'active' COMMENT '状态',
  granted_by INT COMMENT '授权者ID',
  granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '授权时间',
  expires_at TIMESTAMP NULL COMMENT '过期时间',
  
  FOREIGN KEY (user_id) REFERENCES admin_users(id) ON DELETE CASCADE,
  FOREIGN KEY (role_id) REFERENCES admin_roles(id) ON DELETE CASCADE,
  UNIQUE KEY uk_user_role (user_id, role_id),
  INDEX idx_user_id (user_id),
  INDEX idx_role_id (role_id),
  INDEX idx_status (status)
) COMMENT '用户角色关联表';
```

#### 角色权限关联表 (admin_role_permissions)
```sql
CREATE TABLE admin_role_permissions (
  id INT PRIMARY KEY AUTO_INCREMENT,
  role_id INT NOT NULL COMMENT '角色ID',
  permission_id INT NOT NULL COMMENT '权限ID',
  status ENUM('active', 'inactive') DEFAULT 'active' COMMENT '状态',
  granted_by INT COMMENT '授权者ID',
  granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '授权时间',
  
  FOREIGN KEY (role_id) REFERENCES admin_roles(id) ON DELETE CASCADE,
  FOREIGN KEY (permission_id) REFERENCES admin_permissions(id) ON DELETE CASCADE,
  UNIQUE KEY uk_role_permission (role_id, permission_id),
  INDEX idx_role_id (role_id),
  INDEX idx_permission_id (permission_id),
  INDEX idx_status (status)
) COMMENT '角色权限关联表';
```

### 2. 预定义角色和权限

#### 系统角色定义
```javascript
const SYSTEM_ROLES = {
  SUPER_ADMIN: {
    code: 'super_admin',
    name: '超级管理员',
    description: '拥有系统所有权限，可以管理其他管理员',
    level: 100,
    permissions: ['*'] // 所有权限
  },
  
  ADMIN: {
    code: 'admin',
    name: '系统管理员',
    description: '拥有大部分管理权限，不能管理其他管理员',
    level: 80,
    permissions: [
      'user:*', 'wallet:*', 'transaction:*', 
      'task:*', 'redpacket:*', 'team:*', 
      'ranking:*', 'monitoring:read'
    ]
  },
  
  FINANCE_MANAGER: {
    code: 'finance_manager',
    name: '财务管理员',
    description: '负责财务相关功能管理',
    level: 60,
    permissions: [
      'wallet:read', 'wallet:manage', 'transaction:*',
      'user:read', 'monitoring:read'
    ]
  },
  
  OPERATION_MANAGER: {
    code: 'operation_manager',
    name: '运营管理员',
    description: '负责运营活动管理',
    level: 50,
    permissions: [
      'task:*', 'redpacket:*', 'team:read', 
      'ranking:*', 'user:read', 'monitoring:read'
    ]
  },
  
  CUSTOMER_SERVICE: {
    code: 'customer_service',
    name: '客服专员',
    description: '负责用户服务和基础查询',
    level: 30,
    permissions: [
      'user:read', 'user:update_basic', 'wallet:read',
      'transaction:read', 'team:read'
    ]
  },
  
  AUDITOR: {
    code: 'auditor',
    name: '审计专员',
    description: '负责审计和监控，只读权限',
    level: 40,
    permissions: [
      'user:read', 'wallet:read', 'transaction:read',
      'task:read', 'redpacket:read', 'team:read',
      'ranking:read', 'monitoring:read', 'audit:*'
    ]
  }
};
```

#### 权限定义
```javascript
const SYSTEM_PERMISSIONS = {
  // 用户管理权限
  USER_READ: { code: 'user:read', name: '查看用户', resource: 'user', action: 'read' },
  USER_CREATE: { code: 'user:create', name: '创建用户', resource: 'user', action: 'create' },
  USER_UPDATE: { code: 'user:update', name: '更新用户', resource: 'user', action: 'update' },
  USER_DELETE: { code: 'user:delete', name: '删除用户', resource: 'user', action: 'delete' },
  USER_UPDATE_BASIC: { code: 'user:update_basic', name: '更新基础信息', resource: 'user', action: 'update_basic' },
  USER_FREEZE: { code: 'user:freeze', name: '冻结用户', resource: 'user', action: 'freeze' },
  USER_EXPORT: { code: 'user:export', name: '导出用户数据', resource: 'user', action: 'export' },
  
  // 钱包管理权限
  WALLET_READ: { code: 'wallet:read', name: '查看钱包', resource: 'wallet', action: 'read' },
  WALLET_MANAGE: { code: 'wallet:manage', name: '管理钱包', resource: 'wallet', action: 'manage' },
  WALLET_COLLECT: { code: 'wallet:collect', name: '资金归集', resource: 'wallet', action: 'collect' },
  WALLET_EXPORT: { code: 'wallet:export', name: '导出钱包数据', resource: 'wallet', action: 'export' },
  
  // 交易管理权限
  TRANSACTION_READ: { code: 'transaction:read', name: '查看交易', resource: 'transaction', action: 'read' },
  TRANSACTION_APPROVE: { code: 'transaction:approve', name: '审批交易', resource: 'transaction', action: 'approve' },
  TRANSACTION_REJECT: { code: 'transaction:reject', name: '拒绝交易', resource: 'transaction', action: 'reject' },
  TRANSACTION_EXPORT: { code: 'transaction:export', name: '导出交易数据', resource: 'transaction', action: 'export' },
  
  // 任务管理权限
  TASK_READ: { code: 'task:read', name: '查看任务', resource: 'task', action: 'read' },
  TASK_CREATE: { code: 'task:create', name: '创建任务', resource: 'task', action: 'create' },
  TASK_UPDATE: { code: 'task:update', name: '更新任务', resource: 'task', action: 'update' },
  TASK_DELETE: { code: 'task:delete', name: '删除任务', resource: 'task', action: 'delete' },
  TASK_PUBLISH: { code: 'task:publish', name: '发布任务', resource: 'task', action: 'publish' },
  
  // 红包管理权限
  REDPACKET_READ: { code: 'redpacket:read', name: '查看红包', resource: 'redpacket', action: 'read' },
  REDPACKET_CREATE: { code: 'redpacket:create', name: '创建红包', resource: 'redpacket', action: 'create' },
  REDPACKET_UPDATE: { code: 'redpacket:update', name: '更新红包', resource: 'redpacket', action: 'update' },
  REDPACKET_DELETE: { code: 'redpacket:delete', name: '删除红包', resource: 'redpacket', action: 'delete' },
  
  // 团队管理权限
  TEAM_READ: { code: 'team:read', name: '查看团队', resource: 'team', action: 'read' },
  TEAM_MANAGE: { code: 'team:manage', name: '管理团队', resource: 'team', action: 'manage' },
  TEAM_EXPORT: { code: 'team:export', name: '导出团队数据', resource: 'team', action: 'export' },
  
  // 排行榜管理权限
  RANKING_READ: { code: 'ranking:read', name: '查看排行榜', resource: 'ranking', action: 'read' },
  RANKING_MANAGE: { code: 'ranking:manage', name: '管理排行榜', resource: 'ranking', action: 'manage' },
  RANKING_RESET: { code: 'ranking:reset', name: '重置排行榜', resource: 'ranking', action: 'reset' },
  
  // 监控管理权限
  MONITORING_READ: { code: 'monitoring:read', name: '查看监控', resource: 'monitoring', action: 'read' },
  MONITORING_MANAGE: { code: 'monitoring:manage', name: '管理监控', resource: 'monitoring', action: 'manage' },
  MONITORING_ALERT: { code: 'monitoring:alert', name: '管理告警', resource: 'monitoring', action: 'alert' },
  
  // 系统管理权限
  SYSTEM_CONFIG: { code: 'system:config', name: '系统配置', resource: 'system', action: 'config' },
  SYSTEM_BACKUP: { code: 'system:backup', name: '系统备份', resource: 'system', action: 'backup' },
  SYSTEM_MAINTENANCE: { code: 'system:maintenance', name: '系统维护', resource: 'system', action: 'maintenance' },
  
  // 管理员管理权限
  ADMIN_READ: { code: 'admin:read', name: '查看管理员', resource: 'admin', action: 'read' },
  ADMIN_CREATE: { code: 'admin:create', name: '创建管理员', resource: 'admin', action: 'create' },
  ADMIN_UPDATE: { code: 'admin:update', name: '更新管理员', resource: 'admin', action: 'update' },
  ADMIN_DELETE: { code: 'admin:delete', name: '删除管理员', resource: 'admin', action: 'delete' },
  
  // 角色权限管理
  ROLE_READ: { code: 'role:read', name: '查看角色', resource: 'role', action: 'read' },
  ROLE_CREATE: { code: 'role:create', name: '创建角色', resource: 'role', action: 'create' },
  ROLE_UPDATE: { code: 'role:update', name: '更新角色', resource: 'role', action: 'update' },
  ROLE_DELETE: { code: 'role:delete', name: '删除角色', resource: 'role', action: 'delete' },
  
  // 审计权限
  AUDIT_READ: { code: 'audit:read', name: '查看审计日志', resource: 'audit', action: 'read' },
  AUDIT_EXPORT: { code: 'audit:export', name: '导出审计日志', resource: 'audit', action: 'export' }
};
```

## 安全防护机制

### 1. 身份认证安全

#### 密码安全策略
```javascript
/**
 * 密码安全管理
 */
class PasswordSecurity {
  /**
   * 密码强度验证
   * @param {string} password - 密码
   * @returns {Object} 验证结果
   */
  validatePasswordStrength(password) {
    const rules = {
      minLength: 8,
      maxLength: 128,
      requireUppercase: true,
      requireLowercase: true,
      requireNumbers: true,
      requireSpecialChars: true,
      forbiddenPatterns: [
        /(.)\1{2,}/, // 连续相同字符
        /123456|654321|qwerty|password/i, // 常见弱密码
      ]
    };
    
    const errors = [];
    
    if (password.length < rules.minLength) {
      errors.push(`密码长度不能少于${rules.minLength}位`);
    }
    
    if (password.length > rules.maxLength) {
      errors.push(`密码长度不能超过${rules.maxLength}位`);
    }
    
    if (rules.requireUppercase && !/[A-Z]/.test(password)) {
      errors.push('密码必须包含大写字母');
    }
    
    if (rules.requireLowercase && !/[a-z]/.test(password)) {
      errors.push('密码必须包含小写字母');
    }
    
    if (rules.requireNumbers && !/\d/.test(password)) {
      errors.push('密码必须包含数字');
    }
    
    if (rules.requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
      errors.push('密码必须包含特殊字符');
    }
    
    for (const pattern of rules.forbiddenPatterns) {
      if (pattern.test(password)) {
        errors.push('密码包含不安全的模式');
        break;
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      strength: this.calculatePasswordStrength(password)
    };
  }
  
  /**
   * 密码哈希
   * @param {string} password - 明文密码
   * @returns {Object} 哈希结果
   */
  async hashPassword(password) {
    const salt = crypto.randomBytes(16).toString('hex');
    const hash = await bcrypt.hash(password + salt, 12);
    
    return { hash, salt };
  }
  
  /**
   * 密码验证
   * @param {string} password - 明文密码
   * @param {string} hash - 存储的哈希
   * @param {string} salt - 盐值
   * @returns {boolean} 验证结果
   */
  async verifyPassword(password, hash, salt) {
    return await bcrypt.compare(password + salt, hash);
  }
}
```

#### 双因素认证 (2FA)
```javascript
/**
 * 双因素认证管理
 */
class TwoFactorAuth {
  /**
   * 生成2FA密钥
   * @param {string} username - 用户名
   * @returns {Object} 2FA配置
   */
  generateSecret(username) {
    const secret = speakeasy.generateSecret({
      name: `数字钱包管理后台 (${username})`,
      issuer: '数字钱包',
      length: 32
    });
    
    return {
      secret: secret.base32,
      qrCode: qrcode.toDataURL(secret.otpauth_url),
      backupCodes: this.generateBackupCodes()
    };
  }
  
  /**
   * 验证TOTP码
   * @param {string} secret - 2FA密钥
   * @param {string} token - TOTP码
   * @returns {boolean} 验证结果
   */
  verifyTOTP(secret, token) {
    return speakeasy.totp.verify({
      secret,
      encoding: 'base32',
      token,
      window: 2 // 允许时间窗口偏差
    });
  }
  
  /**
   * 生成备用码
   * @returns {Array} 备用码列表
   */
  generateBackupCodes() {
    const codes = [];
    for (let i = 0; i < 10; i++) {
      codes.push(crypto.randomBytes(4).toString('hex').toUpperCase());
    }
    return codes;
  }
}
```

### 2. 会话管理安全

#### JWT令牌管理
```javascript
/**
 * JWT令牌管理
 */
class TokenManager {
  /**
   * 生成访问令牌
   * @param {Object} user - 用户信息
   * @returns {Object} 令牌信息
   */
  generateTokens(user) {
    const payload = {
      userId: user.id,
      username: user.username,
      roles: user.roles,
      sessionId: crypto.randomUUID()
    };
    
    // 访问令牌 - 15分钟
    const accessToken = jwt.sign(payload, process.env.JWT_SECRET, {
      expiresIn: '15m',
      issuer: 'wallet-admin',
      audience: 'wallet-admin-client'
    });
    
    // 刷新令牌 - 7天
    const refreshToken = jwt.sign(
      { userId: user.id, sessionId: payload.sessionId },
      process.env.JWT_REFRESH_SECRET,
      { expiresIn: '7d' }
    );
    
    return {
      accessToken,
      refreshToken,
      expiresIn: 15 * 60, // 15分钟
      tokenType: 'Bearer'
    };
  }
  
  /**
   * 刷新访问令牌
   * @param {string} refreshToken - 刷新令牌
   * @returns {Object} 新的令牌信息
   */
  async refreshAccessToken(refreshToken) {
    try {
      const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);
      
      // 检查刷新令牌是否在黑名单中
      const isBlacklisted = await redis.get(`refresh_blacklist:${refreshToken}`);
      if (isBlacklisted) {
        throw new Error('刷新令牌已失效');
      }
      
      // 获取用户信息
      const user = await User.findById(decoded.userId);
      if (!user || user.status !== 'active') {
        throw new Error('用户不存在或已被禁用');
      }
      
      // 生成新的访问令牌
      const newTokens = this.generateTokens(user);
      
      // 将旧的刷新令牌加入黑名单
      await redis.setex(
        `refresh_blacklist:${refreshToken}`,
        7 * 24 * 60 * 60, // 7天
        '1'
      );
      
      return newTokens;
      
    } catch (error) {
      throw new Error('刷新令牌验证失败');
    }
  }
  
  /**
   * 撤销令牌
   * @param {string} token - 访问令牌
   * @param {string} refreshToken - 刷新令牌
   */
  async revokeTokens(token, refreshToken) {
    const decoded = jwt.decode(token);
    const expiresIn = decoded.exp - Math.floor(Date.now() / 1000);
    
    // 将访问令牌加入黑名单
    if (expiresIn > 0) {
      await redis.setex(`blacklist:${token}`, expiresIn, '1');
    }
    
    // 将刷新令牌加入黑名单
    await redis.setex(
      `refresh_blacklist:${refreshToken}`,
      7 * 24 * 60 * 60,
      '1'
    );
  }
}
```

### 3. 访问控制安全

#### IP白名单管理
```javascript
/**
 * IP访问控制
 */
class IPAccessControl {
  /**
   * IP白名单验证中间件
   * @returns {Function} Express中间件
   */
  ipWhitelistMiddleware() {
    return async (req, res, next) => {
      const clientIP = this.getClientIP(req);
      
      // 检查IP是否在白名单中
      const isAllowed = await this.isIPAllowed(clientIP);
      
      if (!isAllowed) {
        // 记录非法访问
        await this.logUnauthorizedAccess(clientIP, req);
        
        return res.status(403).json({
          success: false,
          code: 403,
          message: 'IP地址不在允许范围内'
        });
      }
      
      next();
    };
  }
  
  /**
   * 获取客户端真实IP
   * @param {Object} req - 请求对象
   * @returns {string} IP地址
   */
  getClientIP(req) {
    return req.headers['x-forwarded-for'] ||
           req.headers['x-real-ip'] ||
           req.connection.remoteAddress ||
           req.socket.remoteAddress ||
           req.ip;
  }
  
  /**
   * 检查IP是否被允许
   * @param {string} ip - IP地址
   * @returns {boolean} 是否允许
   */
  async isIPAllowed(ip) {
    // 检查IP白名单
    const whitelist = await redis.smembers('ip_whitelist');
    
    for (const allowedIP of whitelist) {
      if (this.matchIP(ip, allowedIP)) {
        return true;
      }
    }
    
    return false;
  }
  
  /**
   * IP匹配检查(支持CIDR)
   * @param {string} ip - 客户端IP
   * @param {string} pattern - 匹配模式
   * @returns {boolean} 是否匹配
   */
  matchIP(ip, pattern) {
    if (pattern.includes('/')) {
      // CIDR格式
      const [network, prefixLength] = pattern.split('/');
      return this.isIPInCIDR(ip, network, parseInt(prefixLength));
    } else {
      // 精确匹配
      return ip === pattern;
    }
  }
}
```

#### 速率限制
```javascript
/**
 * 速率限制管理
 */
class RateLimiter {
  /**
   * 创建速率限制中间件
   * @param {Object} options - 配置选项
   * @returns {Function} Express中间件
   */
  createLimiter(options = {}) {
    const {
      windowMs = 15 * 60 * 1000, // 15分钟
      max = 100, // 最大请求数
      keyGenerator = (req) => req.ip,
      skipSuccessfulRequests = false,
      skipFailedRequests = false
    } = options;
    
    return async (req, res, next) => {
      const key = `rate_limit:${keyGenerator(req)}`;
      const now = Date.now();
      const windowStart = now - windowMs;
      
      // 清理过期记录
      await redis.zremrangebyscore(key, 0, windowStart);
      
      // 获取当前窗口内的请求数
      const requestCount = await redis.zcard(key);
      
      if (requestCount >= max) {
        return res.status(429).json({
          success: false,
          code: 429,
          message: '请求过于频繁，请稍后再试',
          retryAfter: Math.ceil(windowMs / 1000)
        });
      }
      
      // 记录当前请求
      await redis.zadd(key, now, `${now}-${Math.random()}`);
      await redis.expire(key, Math.ceil(windowMs / 1000));
      
      // 设置响应头
      res.set({
        'X-RateLimit-Limit': max,
        'X-RateLimit-Remaining': Math.max(0, max - requestCount - 1),
        'X-RateLimit-Reset': new Date(now + windowMs).toISOString()
      });
      
      next();
    };
  }
  
  /**
   * 敏感操作限制
   * @returns {Function} Express中间件
   */
  sensitiveOperationLimiter() {
    return this.createLimiter({
      windowMs: 60 * 60 * 1000, // 1小时
      max: 10, // 最多10次
      keyGenerator: (req) => `${req.ip}:${req.user?.id || 'anonymous'}`,
      message: '敏感操作过于频繁，请稍后再试'
    });
  }
}
```

### 4. 数据安全防护

#### 数据脱敏
```javascript
/**
 * 数据脱敏处理
 */
class DataMasking {
  /**
   * 根据用户权限脱敏数据
   * @param {Object} data - 原始数据
   * @param {Array} userPermissions - 用户权限
   * @returns {Object} 脱敏后的数据
   */
  maskDataByPermissions(data, userPermissions) {
    const sensitiveFields = {
      phone: {
        permission: 'user:view_phone',
        mask: (value) => value.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2')
      },
      email: {
        permission: 'user:view_email',
        mask: (value) => value.replace(/(.{2}).*(@.*)/, '$1***$2')
      },
      walletAddress: {
        permission: 'wallet:view_full_address',
        mask: (value) => `${value.slice(0, 6)}...${value.slice(-6)}`
      },
      idCard: {
        permission: 'user:view_id_card',
        mask: (value) => value.replace(/(\d{6})\d{8}(\d{4})/, '$1********$2')
      },
      realName: {
        permission: 'user:view_real_name',
        mask: (value) => value.replace(/(.{1}).*(.{1})/, '$1***$2')
      }
    };
    
    const maskedData = { ...data };
    
    Object.keys(sensitiveFields).forEach(field => {
      if (maskedData[field]) {
        const fieldConfig = sensitiveFields[field];
        const hasPermission = userPermissions.some(p => 
          p.code === fieldConfig.permission || p.code === '*'
        );
        
        if (!hasPermission) {
          maskedData[field] = fieldConfig.mask(maskedData[field]);
        }
      }
    });
    
    return maskedData;
  }
  
  /**
   * 批量数据脱敏
   * @param {Array} dataList - 数据列表
   * @param {Array} userPermissions - 用户权限
   * @returns {Array} 脱敏后的数据列表
   */
  maskDataList(dataList, userPermissions) {
    return dataList.map(data => this.maskDataByPermissions(data, userPermissions));
  }
}
```

#### 数据加密
```javascript
/**
 * 数据加密管理
 */
class DataEncryption {
  constructor() {
    this.algorithm = 'aes-256-gcm';
    this.keyLength = 32;
    this.ivLength = 16;
    this.tagLength = 16;
  }
  
  /**
   * 加密敏感数据
   * @param {string} plaintext - 明文
   * @param {string} key - 加密密钥
   * @returns {string} 加密结果
   */
  encrypt(plaintext, key = process.env.DATA_ENCRYPTION_KEY) {
    const iv = crypto.randomBytes(this.ivLength);
    const cipher = crypto.createCipher(this.algorithm, key);
    cipher.setAAD(Buffer.from('wallet-admin', 'utf8'));
    
    let encrypted = cipher.update(plaintext, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const tag = cipher.getAuthTag();
    
    return `${iv.toString('hex')}:${tag.toString('hex')}:${encrypted}`;
  }
  
  /**
   * 解密敏感数据
   * @param {string} encryptedData - 加密数据
   * @param {string} key - 解密密钥
   * @returns {string} 明文
   */
  decrypt(encryptedData, key = process.env.DATA_ENCRYPTION_KEY) {
    const [ivHex, tagHex, encrypted] = encryptedData.split(':');
    
    const iv = Buffer.from(ivHex, 'hex');
    const tag = Buffer.from(tagHex, 'hex');
    
    const decipher = crypto.createDecipher(this.algorithm, key);
    decipher.setAAD(Buffer.from('wallet-admin', 'utf8'));
    decipher.setAuthTag(tag);
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

## 审计日志系统

### 1. 操作日志记录

#### 审计日志表结构
```sql
CREATE TABLE admin_audit_logs (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id INT COMMENT '操作用户ID',
  username VARCHAR(50) COMMENT '操作用户名',
  action VARCHAR(100) NOT NULL COMMENT '操作类型',
  resource VARCHAR(50) COMMENT '操作资源',
  resource_id VARCHAR(100) COMMENT '资源ID',
  method VARCHAR(10) COMMENT 'HTTP方法',
  url VARCHAR(500) COMMENT '请求URL',
  ip_address VARCHAR(45) COMMENT 'IP地址',
  user_agent TEXT COMMENT '用户代理',
  request_data JSON COMMENT '请求数据',
  response_data JSON COMMENT '响应数据',
  status_code INT COMMENT '响应状态码',
  duration INT COMMENT '执行时间(毫秒)',
  success BOOLEAN COMMENT '是否成功',
  error_message TEXT COMMENT '错误信息',
  session_id VARCHAR(100) COMMENT '会话ID',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  INDEX idx_user_id (user_id),
  INDEX idx_action (action),
  INDEX idx_resource (resource),
  INDEX idx_ip_address (ip_address),
  INDEX idx_created_at (created_at),
  INDEX idx_success (success)
) COMMENT '管理员操作审计日志';
```

#### 审计日志记录器
```javascript
/**
 * 审计日志记录器
 */
class AuditLogger {
  /**
   * 审计日志中间件
   * @returns {Function} Express中间件
   */
  auditMiddleware() {
    return (req, res, next) => {
      const startTime = Date.now();
      const originalSend = res.send;
      
      // 记录请求信息
      const auditData = {
        userId: req.user?.id,
        username: req.user?.username,
        method: req.method,
        url: req.originalUrl,
        ipAddress: this.getClientIP(req),
        userAgent: req.get('User-Agent'),
        sessionId: req.user?.sessionId,
        requestData: this.sanitizeRequestData(req)
      };
      
      // 拦截响应
      res.send = function(data) {
        const duration = Date.now() - startTime;
        
        auditData.responseData = this.sanitizeResponseData(data);
        auditData.statusCode = res.statusCode;
        auditData.duration = duration;
        auditData.success = res.statusCode < 400;
        
        // 异步记录日志
        setImmediate(() => {
          this.logAuditEvent(auditData);
        });
        
        return originalSend.call(this, data);
      }.bind(this);
      
      next();
    };
  }
  
  /**
   * 记录审计事件
   * @param {Object} auditData - 审计数据
   */
  async logAuditEvent(auditData) {
    try {
      // 确定操作类型
      auditData.action = this.determineAction(auditData);
      auditData.resource = this.determineResource(auditData.url);
      auditData.resourceId = this.extractResourceId(auditData.url);
      
      // 插入数据库
      await db.query(`
        INSERT INTO admin_audit_logs (
          user_id, username, action, resource, resource_id,
          method, url, ip_address, user_agent, request_data,
          response_data, status_code, duration, success,
          error_message, session_id, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
      `, [
        auditData.userId, auditData.username, auditData.action,
        auditData.resource, auditData.resourceId, auditData.method,
        auditData.url, auditData.ipAddress, auditData.userAgent,
        JSON.stringify(auditData.requestData),
        JSON.stringify(auditData.responseData),
        auditData.statusCode, auditData.duration, auditData.success,
        auditData.errorMessage, auditData.sessionId
      ]);
      
      // 实时告警检查
      await this.checkSecurityAlerts(auditData);
      
    } catch (error) {
      console.error('审计日志记录失败:', error);
    }
  }
  
  /**
   * 确定操作类型
   * @param {Object} auditData - 审计数据
   * @returns {string} 操作类型
   */
  determineAction(auditData) {
    const { method, url } = auditData;
    
    const actionMap = {
      'POST /api/admin/login': 'admin_login',
      'POST /api/admin/logout': 'admin_logout',
      'GET /api/admin/users': 'view_users',
      'POST /api/admin/users': 'create_user',
      'PUT /api/admin/users': 'update_user',
      'DELETE /api/admin/users': 'delete_user',
      'POST /api/admin/users/*/freeze': 'freeze_user',
      'POST /api/admin/wallet/collect-funds': 'collect_funds',
      'PUT /api/admin/transactions/*/approve': 'approve_transaction',
      'PUT /api/admin/transactions/*/reject': 'reject_transaction'
    };
    
    // 精确匹配
    const exactMatch = actionMap[`${method} ${url}`];
    if (exactMatch) return exactMatch;
    
    // 模式匹配
    for (const [pattern, action] of Object.entries(actionMap)) {
      const regex = new RegExp(pattern.replace(/\*/g, '[^/]+'));
      if (regex.test(`${method} ${url}`)) {
        return action;
      }
    }
    
    return `${method.toLowerCase()}_${this.determineResource(url)}`;
  }
  
  /**
   * 安全告警检查
   * @param {Object} auditData - 审计数据
   */
  async checkSecurityAlerts(auditData) {
    // 检查失败登录尝试
    if (auditData.action === 'admin_login' && !auditData.success) {
      await this.checkFailedLoginAttempts(auditData.ipAddress);
    }
    
    // 检查敏感操作
    const sensitiveActions = [
      'delete_user', 'freeze_user', 'collect_funds',
      'approve_transaction', 'create_admin'
    ];
    
    if (sensitiveActions.includes(auditData.action)) {
      await this.alertSensitiveOperation(auditData);
    }
    
    // 检查异常IP访问
    await this.checkAnomalousIPAccess(auditData);
  }
}
```

### 2. 安全事件监控

#### 安全告警系统
```javascript
/**
 * 安全告警系统
 */
class SecurityAlertSystem {
  /**
   * 检查失败登录尝试
   * @param {string} ipAddress - IP地址
   */
  async checkFailedLoginAttempts(ipAddress) {
    const key = `failed_login:${ipAddress}`;
    const attempts = await redis.incr(key);
    
    if (attempts === 1) {
      await redis.expire(key, 3600); // 1小时过期
    }
    
    // 5次失败尝试触发告警
    if (attempts >= 5) {
      await this.sendAlert({
        type: 'FAILED_LOGIN_ATTEMPTS',
        severity: 'HIGH',
        message: `IP ${ipAddress} 在1小时内登录失败${attempts}次`,
        data: { ipAddress, attempts }
      });
      
      // 临时封禁IP
      await redis.setex(`blocked_ip:${ipAddress}`, 3600, '1');
    }
  }
  
  /**
   * 敏感操作告警
   * @param {Object} auditData - 审计数据
   */
  async alertSensitiveOperation(auditData) {
    await this.sendAlert({
      type: 'SENSITIVE_OPERATION',
      severity: 'MEDIUM',
      message: `用户 ${auditData.username} 执行了敏感操作: ${auditData.action}`,
      data: auditData
    });
  }
  
  /**
   * 异常IP访问检查
   * @param {Object} auditData - 审计数据
   */
  async checkAnomalousIPAccess(auditData) {
    if (!auditData.userId) return;
    
    // 获取用户历史IP
    const historicalIPs = await redis.smembers(`user_ips:${auditData.userId}`);
    
    if (historicalIPs.length > 0 && !historicalIPs.includes(auditData.ipAddress)) {
      await this.sendAlert({
        type: 'ANOMALOUS_IP_ACCESS',
        severity: 'MEDIUM',
        message: `用户 ${auditData.username} 从新IP地址 ${auditData.ipAddress} 访问系统`,
        data: { 
          userId: auditData.userId,
          newIP: auditData.ipAddress,
          historicalIPs 
        }
      });
    }
    
    // 记录当前IP
    await redis.sadd(`user_ips:${auditData.userId}`, auditData.ipAddress);
    await redis.expire(`user_ips:${auditData.userId}`, 30 * 24 * 3600); // 30天
  }
  
  /**
   * 发送告警
   * @param {Object} alert - 告警信息
   */
  async sendAlert(alert) {
    const alertData = {
      ...alert,
      id: crypto.randomUUID(),
      timestamp: new Date().toISOString(),
      status: 'active'
    };
    
    // 存储告警
    await redis.lpush('security_alerts', JSON.stringify(alertData));
    await redis.ltrim('security_alerts', 0, 999); // 保留最近1000条
    
    // 实时推送告警
    this.broadcastAlert(alertData);
    
    // 发送通知
    await this.sendNotification(alertData);
  }
  
  /**
   * 实时推送告警
   * @param {Object} alert - 告警信息
   */
  broadcastAlert(alert) {
    // WebSocket推送给在线管理员
    const io = require('../socket');
    io.to('admins').emit('security_alert', alert);
  }
}
```

## 配置管理

### 1. 安全配置

#### 系统安全配置
```javascript
const SECURITY_CONFIG = {
  // 密码策略
  password: {
    minLength: 8,
    maxLength: 128,
    requireUppercase: true,
    requireLowercase: true,
    requireNumbers: true,
    requireSpecialChars: true,
    maxAge: 90 * 24 * 60 * 60 * 1000, // 90天
    historyCount: 5 // 不能重复使用最近5个密码
  },
  
  // 会话管理
  session: {
    accessTokenExpiry: 15 * 60, // 15分钟
    refreshTokenExpiry: 7 * 24 * 60 * 60, // 7天
    maxConcurrentSessions: 3, // 最大并发会话数
    idleTimeout: 30 * 60 // 30分钟无操作自动登出
  },
  
  // 登录安全
  login: {
    maxFailedAttempts: 5,
    lockoutDuration: 60 * 60, // 1小时
    requireTwoFactor: false, // 是否强制2FA
    allowedIPRanges: [] // 允许的IP范围
  },
  
  // 操作限制
  operations: {
    sensitiveOperationLimit: 10, // 每小时敏感操作次数限制
    bulkOperationLimit: 100, // 批量操作数量限制
    exportLimit: 10000 // 导出数据条数限制
  },
  
  // 数据保护
  dataProtection: {
    encryptSensitiveData: true,
    maskingEnabled: true,
    auditLogRetention: 365 * 24 * 60 * 60, // 审计日志保留1年
    backupEncryption: true
  }
};
```

### 2. 权限配置管理

#### 动态权限配置
```javascript
/**
 * 权限配置管理
 */
class PermissionConfigManager {
  /**
   * 获取权限配置
   * @returns {Object} 权限配置
   */
  async getPermissionConfig() {
    const config = await redis.get('permission_config');
    return config ? JSON.parse(config) : this.getDefaultConfig();
  }
  
  /**
   * 更新权限配置
   * @param {Object} config - 新配置
   */
  async updatePermissionConfig(config) {
    // 验证配置格式
    this.validateConfig(config);
    
    // 保存配置
    await redis.set('permission_config', JSON.stringify(config));
    
    // 清除权限缓存
    await this.clearPermissionCache();
    
    // 记录配置变更
    await this.logConfigChange(config);
  }
  
  /**
   * 获取默认配置
   * @returns {Object} 默认权限配置
   */
  getDefaultConfig() {
    return {
      roles: SYSTEM_ROLES,
      permissions: SYSTEM_PERMISSIONS,
      rules: {
        // 权限继承规则
        inheritance: {
          'super_admin': ['admin', 'finance_manager', 'operation_manager'],
          'admin': ['finance_manager', 'operation_manager', 'customer_service'],
          'finance_manager': ['auditor'],
          'operation_manager': ['customer_service']
        },
        
        // 权限约束规则
        constraints: {
          // 不能删除自己
          'admin:delete': {
            condition: 'target_id != user_id',
            message: '不能删除自己的账户'
          },
          
          // 不能修改更高级别的用户
          'admin:update': {
            condition: 'target_level <= user_level',
            message: '不能修改更高级别的管理员'
          }
        }
      }
    };
  }
}
```

## 部署和运维

### 1. 安全部署配置

#### Docker安全配置
```dockerfile
# Dockerfile
FROM node:18-alpine

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# 设置工作目录
WORKDIR /app

# 复制依赖文件
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# 复制应用代码
COPY --chown=nextjs:nodejs . .

# 切换到非root用户
USER nextjs

# 暴露端口
EXPOSE 3000

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/api/health || exit 1

# 启动应用
CMD ["npm", "start"]
```

#### Nginx安全配置
```nginx
# nginx.conf
server {
    listen 443 ssl http2;
    server_name admin.wallet.com;
    
    # SSL配置
    ssl_certificate /etc/ssl/certs/admin.wallet.com.crt;
    ssl_certificate_key /etc/ssl/private/admin.wallet.com.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    
    # 安全头
    add_header Strict-Transport-Security "max-age=63072000" always;
    add_header X-Frame-Options DENY always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';" always;
    
    # 隐藏服务器信息
    server_tokens off;
    
    # 限制请求大小
    client_max_body_size 10M;
    
    # 速率限制
    limit_req_zone $binary_remote_addr zone=admin:10m rate=10r/m;
    limit_req zone=admin burst=20 nodelay;
    
    # 代理配置
    location /api/ {
        proxy_pass http://backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # 超时设置
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }
    
    # 静态文件
    location / {
        root /var/www/admin;
        index index.html;
        try_files $uri $uri/ /index.html;
        
        # 缓存设置
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
}

# HTTP重定向到HTTPS
server {
    listen 80;
    server_name admin.wallet.com;
    return 301 https://$server_name$request_uri;
}
```

### 2. 监控和告警

#### 安全监控指标
```javascript
/**
 * 安全监控指标收集
 */
class SecurityMetrics {
  /**
   * 收集登录指标
   */
  async collectLoginMetrics() {
    const metrics = {
      totalLogins: await this.getTotalLogins(),
      failedLogins: await this.getFailedLogins(),
      uniqueUsers: await this.getUniqueUsers(),
      suspiciousIPs: await this.getSuspiciousIPs(),
      twoFactorUsage: await this.getTwoFactorUsage()
    };
    
    return metrics;
  }
  
  /**
   * 收集权限指标
   */
  async collectPermissionMetrics() {
    const metrics = {
      permissionDenials: await this.getPermissionDenials(),
      privilegeEscalations: await this.getPrivilegeEscalations(),
      roleChanges: await this.getRoleChanges(),
      sensitiveOperations: await this.getSensitiveOperations()
    };
    
    return metrics;
  }
  
  /**
   * 收集系统安全指标
   */
  async collectSystemSecurityMetrics() {
    const metrics = {
      activeAlerts: await this.getActiveAlerts(),
      blockedIPs: await this.getBlockedIPs(),
      sessionCount: await this.getActiveSessionCount(),
      dataBreachAttempts: await this.getDataBreachAttempts()
    };
    
    return metrics;
  }
}
```

### 3. 备份和恢复

#### 安全数据备份
```javascript
/**
 * 安全数据备份管理
 */
class SecurityBackupManager {
  /**
   * 备份安全配置
   */
  async backupSecurityConfig() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupData = {
      timestamp,
      roles: await this.exportRoles(),
      permissions: await this.exportPermissions(),
      userRoles: await this.exportUserRoles(),
      securityConfig: await this.exportSecurityConfig(),
      auditLogs: await this.exportRecentAuditLogs()
    };
    
    // 加密备份数据
    const encryptedData = this.encryptBackupData(backupData);
    
    // 保存到安全存储
    await this.saveBackupToSecureStorage(
      `security-backup-${timestamp}.enc`,
      encryptedData
    );
    
    return {
      success: true,
      backupId: `security-backup-${timestamp}`,
      size: encryptedData.length
    };
  }
  
  /**
   * 恢复安全配置
   * @param {string} backupId - 备份ID
   */
  async restoreSecurityConfig(backupId) {
    // 从安全存储获取备份
    const encryptedData = await this.getBackupFromSecureStorage(backupId);
    
    // 解密备份数据
    const backupData = this.decryptBackupData(encryptedData);
    
    // 验证备份完整性
    if (!this.validateBackupIntegrity(backupData)) {
      throw new Error('备份数据完整性验证失败');
    }
    
    // 开始恢复过程
    await this.performRestore(backupData);
    
    return {
      success: true,
      restoredAt: new Date().toISOString()
    };
  }
}
```

## 安全测试和验证

### 1. 安全测试用例

#### 认证安全测试
```javascript
/**
 * 认证安全测试套件
 */
describe('认证安全测试', () => {
  test('密码强度验证', async () => {
    const weakPasswords = [
      '123456',
      'password',
      'qwerty',
      'abc123',
      '111111'
    ];
    
    for (const password of weakPasswords) {
      const result = passwordSecurity.validatePasswordStrength(password);
      expect(result.isValid).toBe(false);
    }
  });
  
  test('登录失败锁定', async () => {
    const testIP = '192.168.1.100';
    
    // 模拟5次失败登录
    for (let i = 0; i < 5; i++) {
      await request(app)
        .post('/api/admin/login')
        .send({ username: 'test', password: 'wrong' })
        .set('X-Forwarded-For', testIP);
    }
    
    // 第6次应该被阻止
    const response = await request(app)
      .post('/api/admin/login')
      .send({ username: 'test', password: 'correct' })
      .set('X-Forwarded-For', testIP);
    
    expect(response.status).toBe(429);
  });
  
  test('双因素认证', async () => {
    const user = await createTestUser({ twoFactorEnabled: true });
    const secret = user.twoFactorSecret;
    
    // 生成有效的TOTP码
    const validToken = speakeasy.totp({
      secret,
      encoding: 'base32'
    });
    
    const response = await request(app)
      .post('/api/admin/login')
      .send({
        username: user.username,
        password: 'correct',
        totpCode: validToken
      });
    
    expect(response.status).toBe(200);
    expect(response.body.success).toBe(true);
  });
});
```

#### 权限控制测试
```javascript
/**
 * 权限控制测试套件
 */
describe('权限控制测试', () => {
  test('角色权限验证', async () => {
    const customerService = await createTestUser({ role: 'customer_service' });
    const token = generateTestToken(customerService);
    
    // 客服不应该能够删除用户
    const response = await request(app)
      .delete('/api/admin/users/123')
      .set('Authorization', `Bearer ${token}`);
    
    expect(response.status).toBe(403);
  });
  
  test('数据访问权限', async () => {
    const auditor = await createTestUser({ role: 'auditor' });
    const token = generateTestToken(auditor);
    
    // 审计员应该只能查看数据，不能修改
    const getResponse = await request(app)
      .get('/api/admin/users')
      .set('Authorization', `Bearer ${token}`);
    
    expect(getResponse.status).toBe(200);
    
    const updateResponse = await request(app)
      .put('/api/admin/users/123')
      .set('Authorization', `Bearer ${token}`)
      .send({ status: 'inactive' });
    
    expect(updateResponse.status).toBe(403);
  });
  
  test('上下文权限验证', async () => {
    const admin = await createTestUser({ role: 'admin' });
    const superAdmin = await createTestUser({ role: 'super_admin' });
    const adminToken = generateTestToken(admin);
    
    // 普通管理员不能修改超级管理员
    const response = await request(app)
      .put(`/api/admin/users/${superAdmin.id}`)
      .set('Authorization', `Bearer ${adminToken}`)
      .send({ status: 'inactive' });
    
    expect(response.status).toBe(403);
  });
});
```

### 2. 安全漏洞检测

#### 自动化安全扫描
```javascript
/**
 * 安全漏洞扫描器
 */
class SecurityScanner {
  /**
   * SQL注入检测
   */
  async scanSQLInjection() {
    const testPayloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM admin_users --",
      "1' AND (SELECT COUNT(*) FROM admin_users) > 0 --"
    ];
    
    const vulnerabilities = [];
    
    for (const payload of testPayloads) {
      try {
        const response = await request(app)
          .get('/api/admin/users')
          .query({ search: payload });
        
        if (response.status === 200 && this.detectSQLInjectionSuccess(response.body)) {
          vulnerabilities.push({
            type: 'SQL_INJECTION',
            payload,
            endpoint: '/api/admin/users',
            severity: 'HIGH'
          });
        }
      } catch (error) {
        // 预期的错误，说明有防护
      }
    }
    
    return vulnerabilities;
  }
  
  /**
   * XSS漏洞检测
   */
  async scanXSS() {
    const testPayloads = [
      '<script>alert("XSS")</script>',
      '"><script>alert("XSS")</script>',
      'javascript:alert("XSS")',
      '<img src=x onerror=alert("XSS")>'
    ];
    
    const vulnerabilities = [];
    
    for (const payload of testPayloads) {
      const response = await request(app)
        .post('/api/admin/users')
        .send({ name: payload });
      
      if (response.body && response.body.toString().includes(payload)) {
        vulnerabilities.push({
          type: 'XSS',
          payload,
          endpoint: '/api/admin/users',
          severity: 'MEDIUM'
        });
      }
    }
    
    return vulnerabilities;
  }
  
  /**
   * 权限绕过检测
   */
  async scanPrivilegeEscalation() {
    const vulnerabilities = [];
    
    // 测试未授权访问
    const unauthorizedEndpoints = [
      '/api/admin/system/config',
      '/api/admin/users/export',
      '/api/admin/backup'
    ];
    
    for (const endpoint of unauthorizedEndpoints) {
      const response = await request(app).get(endpoint);
      
      if (response.status === 200) {
        vulnerabilities.push({
          type: 'UNAUTHORIZED_ACCESS',
          endpoint,
          severity: 'HIGH'
        });
      }
    }
    
    return vulnerabilities;
  }
}
```

## 总结

本安全和权限系统设计文档提供了完整的管理后台安全解决方案，包括：

### 核心特性
1. **多层安全防护** - 网络、应用、认证、数据四层安全架构
2. **RBAC权限模型** - 基于角色的访问控制，支持细粒度权限管理
3. **强身份认证** - 密码策略、双因素认证、会话管理
4. **全面审计** - 操作日志、安全事件监控、实时告警
5. **数据保护** - 数据加密、脱敏、备份恢复

### 安全保障
- 防止常见Web攻击（SQL注入、XSS、CSRF等）
- 实时安全监控和告警
- 完整的审计追踪
- 自动化安全测试和漏洞检测
- 灾难恢复和业务连续性

### 合规性
- 符合金融行业安全标准
- 满足数据保护法规要求
- 完整的操作审计记录
- 数据访问权限控制

该系统设计确保了管理后台的高安全性、可控性和合规性，为数字钱包业务提供了坚实的安全基础。